<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>algorithms on adventures in optimization</title>
    <link>https://ryanjoneil.github.io/tags/algorithms/</link>
    <description>Recent content in algorithms on adventures in optimization</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 25 Nov 2011 00:00:00 +0000</lastBuildDate><atom:link href="https://ryanjoneil.github.io/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>⏳️ Know Your Time Complexities - Part 2</title>
      <link>https://ryanjoneil.github.io/posts/2011-11-25-know-your-time-complexities-part-2/</link>
      <pubDate>Fri, 25 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>https://ryanjoneil.github.io/posts/2011-11-25-know-your-time-complexities-part-2/</guid>
      <description>More on the importance of time complexity in basic programming</description>
      <content:encoded><![CDATA[<p>In response to <a href="../2011-10-25-know-your-time-complexities/">this</a> post, <a href="https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs">Ben Bitdiddle</a> inquires:</p>
<blockquote>
<p>I understand the concept of using a companion set to remove duplicates from a list while preserving the order of its elements. But what should I do if these elements are composed of smaller pieces? For instance, say I am generating <a href="https://en.wikipedia.org/wiki/Combination">combinations</a> of numbers in which order is unimportant. How do I make a set recognize that <code>[1,2,3]</code> is the same as <code>[3,2,1]</code> in this case?</p>
</blockquote>
<p>There are a couple points that should help here.</p>
<p>While lists are unhashable and therefore cannot be put into sets, tuples are perfectly capable of this. Therefore I cannot do this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>s <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add([<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>])
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>Traceback (most recent call last):
</span></span><span style="display:flex;"><span> File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
</span></span><span style="display:flex;"><span>TypeError: unhashable type: &#39;list&#39;
</span></span></code></pre></div><p>But this works just fine <em>(extra space added for emphasis of tuple parentheses)</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>s<span style="color:#f92672">.</span>add( (<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>) )
</span></span></code></pre></div><p><code>(3,2,1)</code> and <code>(1,2,3)</code> may not hash to the same thing, but tuples are easily sortable. If I sort them before adding them to a set, they look the same.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>tuple(sorted( (<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>) ))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
</span></span></code></pre></div><p>If I want to be a little fancier, I can user <a href="https://docs.python.org/3/library/itertools.html#itertools.combinations"><code>itertools.combinations</code></a>. The following generates all unique 3-digit combinations of integers from 1 to 4:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> itertools <span style="color:#f92672">import</span> combinations
</span></span><span style="display:flex;"><span>list(combinations(range(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">5</span>), <span style="color:#ae81ff">3</span>))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>[(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>), (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>), (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>)]
</span></span></code></pre></div><p>Now say I want to only find those that match some condition. I can add a filter to return, say, only those 3-digit combinations of integers from 1 to 6 that multiply to a number divisible by 10:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>list(filter(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">lambda</span> x: <span style="color:#f92672">not</span> (x[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>x[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span>x[<span style="color:#ae81ff">2</span>]) <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>,
</span></span><span style="display:flex;"><span>    combinations(range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">7</span>), <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>))
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>[(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>),
</span></span><span style="display:flex;"><span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>),
</span></span><span style="display:flex;"><span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>),
</span></span><span style="display:flex;"><span> (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>),
</span></span><span style="display:flex;"><span> (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>),
</span></span><span style="display:flex;"><span> (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>),
</span></span><span style="display:flex;"><span> (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>),
</span></span><span style="display:flex;"><span> (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>),
</span></span><span style="display:flex;"><span> (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>)]
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
    <item>
      <title>⏳️ Know Your Time Complexities</title>
      <link>https://ryanjoneil.github.io/posts/2011-10-25-know-your-time-complexities/</link>
      <pubDate>Tue, 25 Oct 2011 00:00:00 +0000</pubDate>
      
      <guid>https://ryanjoneil.github.io/posts/2011-10-25-know-your-time-complexities/</guid>
      <description>The importance of time complexity in basic programming</description>
      <content:encoded><![CDATA[<p>This is based on a lightning talk I gave at the LA PyLadies October Hackathon.</p>
<p>I&rsquo;m actually not going to go into anything much resembling algorithmic complexity here. What I&rsquo;d like to do is present a common performance anti-pattern that I see from novice programmers about once every year or so. If I can prevent one person from committing this error, this post will have achieved its goal. I&rsquo;d also like to show how an intuitive understanding of time required by operations in relation to the size of data they operate on can be helpful.</p>
<p>Say you have a Big List of Things. It doesn&rsquo;t particularly matter what these things are. Often they might be objects or dictionaries of denormalized data. In this example we&rsquo;ll use numbers. Let&rsquo;s generate a list of 1 million integers, each randomly chosen from the first 100 thousand natural numbers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> random
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>choices <span style="color:#f92672">=</span> range(<span style="color:#ae81ff">100000</span>)
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> [random<span style="color:#f92672">.</span>choice(choices) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1000000</span>)]
</span></span></code></pre></div><p>Now say you want to remove (or aggregate, or structure) duplicate data while keeping them <em>in order of appearance</em>. Intuitively, this seems simple enough. A first solution might involve creating a new empty list, iterating over x, and only appending those items that are not already in the new list.</p>
<h2 id="the-bad-way">The Bad Way</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>order <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> x:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> order:
</span></span><span style="display:flex;"><span>        order<span style="color:#f92672">.</span>append(i)
</span></span></code></pre></div><p>Try running this. What&rsquo;s wrong with it?</p>
<p>The issue is the conditional on line 3. In the worst case, it could look at every item in the order list for each item in x. If the list is big, as it is in our example, that wastes a lot of cycles. We can reason that we can improve the performance of our code by replacing this conditional with something faster.</p>
<h2 id="the-good-way">The Good Way</h2>
<p>Given that sets have near constant time for membership tests, one solution is to create a companion data structure, which we&rsquo;ll call seen. Being a set, it doesn&rsquo;t care about the order of the items, but it will allow us to test for membership quickly.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>order <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>seen <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> x:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> seen:
</span></span><span style="display:flex;"><span>        seen<span style="color:#f92672">.</span>add(i)
</span></span><span style="display:flex;"><span>        order<span style="color:#f92672">.</span>append(i)
</span></span></code></pre></div><p>Now try running this. Better?</p>
<p>Not that this is the best way to perform this particular action. If you aren&rsquo;t familiar with it, take a look at the <a href="http://docs.python.org/library/itertools.html#itertools.groupby"><code>groupby</code></a> function from <code>itertools</code>, which is what I will sometimes reach for in a case like this.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>👉 Affine Scaling in R</title>
      <link>https://ryanjoneil.github.io/posts/2011-04-27-affine-scaling-in-r/</link>
      <pubDate>Wed, 27 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>https://ryanjoneil.github.io/posts/2011-04-27-affine-scaling-in-r/</guid>
      <description>Affine scaling for interior point optimization in R</description>
      <content:encoded><![CDATA[<p>I recently stumbled across an implementation of the <a href="https://demonstrations.wolfram.com/AffineScalingInteriorPointMethod/">affine scaling</a> <a href="https://en.wikipedia.org/wiki/Interior_point_method">interior point method</a> for solving linear programs that I&rsquo;d coded up in R once upon a time. I&rsquo;m posting it here in case anyone else finds it useful. There&rsquo;s not a whole lot of thought given to efficiency or numerical stability, just a demonstration of the basic algorithm. Still, sometimes that&rsquo;s exactly what one wants.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>solve.affine <span style="color:#f92672">&lt;-</span> <span style="color:#66d9ef">function</span>(A, rc, x, tolerance<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>^<span style="color:#ae81ff">-7</span>, R<span style="color:#f92672">=</span><span style="color:#ae81ff">0.999</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Affine scaling method</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span> (T) {
</span></span><span style="display:flex;"><span>    X_diag <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">diag</span>(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Compute (A * X_diag^2 * A^t)-1 using Cholesky factorization.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># This is responsible for scaling the original problem matrix.</span>
</span></span><span style="display:flex;"><span>    q <span style="color:#f92672">&lt;-</span> A <span style="color:#f92672">%*%</span> X_diag<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">%*%</span> <span style="color:#a6e22e">t</span>(A)
</span></span><span style="display:flex;"><span>    q_inv <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">chol2inv</span>(<span style="color:#a6e22e">chol</span>(q))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># lambda = q * A * X_diag^2 * c</span>
</span></span><span style="display:flex;"><span>    lambda <span style="color:#f92672">&lt;-</span> q_inv <span style="color:#f92672">%*%</span> A <span style="color:#f92672">%*%</span> X_diag^2 <span style="color:#f92672">%*%</span> rc
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># c - A^t * lambda is used repeatedly</span>
</span></span><span style="display:flex;"><span>    foo <span style="color:#f92672">&lt;-</span> rc <span style="color:#f92672">-</span> <span style="color:#a6e22e">t</span>(A) <span style="color:#f92672">%*%</span> lambda
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># We converge as s goes to zero</span>
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">sum</span>((X_diag <span style="color:#f92672">%*%</span> foo)^2))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Compute new x</span>
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">&lt;-</span> (x <span style="color:#f92672">+</span> R <span style="color:#f92672">*</span> X_diag^2 <span style="color:#f92672">%*%</span> foo <span style="color:#f92672">/</span> s)[,]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If s is within our tolerance, stop.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">abs</span>(s) <span style="color:#f92672">&lt;</span> tolerance) <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  x
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function accepts a matrix <code>A</code> which contains all technological coefficients for an LP, a vector <code>rc</code> containing its reduced costs, and an initial point <code>x</code> interior to the LP&rsquo;s feasible region. Optional arguments to the function include a tolerance, for detecting when the method is within an acceptable distance from the optimal point, and a value for <code>R</code>, which must be strictly between 0 and 1 and controls scaling.</p>
<p>The method works by rescaling the matrix <code>A</code> around the current solution <code>x</code>. It then computes a new <code>x</code> such that it remains feasible and interior, which is why <code>R</code> cannot be 0 or 1. It requires a feasible interior point to start and only projects to other feasible interior points, so the right hand side of the LP is not required (it is implicit from the starting point). The shadow prices for each iteration are captured in the vector lambda, so the gap between primal and dual solutions is easy to compute.</p>
<p>We run this function against a 3x3 LP with a known solution:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>max z = 5x1 + 4x2 + 3x3
</span></span><span style="display:flex;"><span>st      2x1 + 3x2 +  x3 &lt;=  5
</span></span><span style="display:flex;"><span>        4x1 +  x2 + 2x3 &lt;= 11
</span></span><span style="display:flex;"><span>        3x1 + 4x2 + 2x3 &lt;=  8
</span></span><span style="display:flex;"><span>        x1, x2, x3 &gt;= 0
</span></span></code></pre></div><p>The optimal solution to this LP is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>z  = 13
</span></span><span style="display:flex;"><span>x1 =  2
</span></span><span style="display:flex;"><span>x2 =  0
</span></span><span style="display:flex;"><span>x3 =  1
</span></span></code></pre></div><p>This problem can be run against the affine scaling function by defining A with all necessary slack variables, and using an arbitrary feasible interior point:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>A <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">matrix</span>(<span style="color:#a6e22e">c</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>), nrow<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, byrow<span style="color:#f92672">=</span>T)
</span></span><span style="display:flex;"><span>rc <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">c</span>(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>x  <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">c</span>(<span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">7.5</span>, <span style="color:#ae81ff">3.5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>solution <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">solve.affine</span>(A, rc, x)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">print</span>(solution)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">print</span>(<span style="color:#a6e22e">sum</span>(solution <span style="color:#f92672">*</span> rc))
</span></span></code></pre></div><p>This provides an output vector that is very close to the optimal primal solution shown above. Since interior point methods converge asymptotically to optimal solutions, it is important to note that we can only ever get (extremely) close to our final optimal objective and decision variable values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">print</span>(solution)
</span></span><span style="display:flex;"><span>[1] <span style="color:#ae81ff">1.999998e+00</span> <span style="color:#ae81ff">4.268595e-07</span> <span style="color:#ae81ff">1.000002e+00</span> <span style="color:#ae81ff">1.280579e-06</span> <span style="color:#ae81ff">1.000005e+00</span>
</span></span><span style="display:flex;"><span>[6] <span style="color:#ae81ff">1.280579e-06</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">print</span>(<span style="color:#a6e22e">sum</span>(solution <span style="color:#f92672">*</span> rc))
</span></span><span style="display:flex;"><span>[1] <span style="color:#ae81ff">13.00000</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
  </channel>
</rss>
