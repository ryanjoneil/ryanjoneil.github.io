<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>algorithms on adventures in optimization</title>
    <link>https://ryanjoneil.github.io/tags/algorithms/</link>
    <description>Recent content in algorithms on adventures in optimization</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 27 Apr 2011 00:00:00 +0000</lastBuildDate><atom:link href="https://ryanjoneil.github.io/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ðŸ‘‰ Affine Scaling in R</title>
      <link>https://ryanjoneil.github.io/posts/2011-04-27-affine-scaling-in-r/</link>
      <pubDate>Wed, 27 Apr 2011 00:00:00 +0000</pubDate>
      
      <guid>https://ryanjoneil.github.io/posts/2011-04-27-affine-scaling-in-r/</guid>
      <description>Affine scaling for interior point optimization in R</description>
      <content:encoded><![CDATA[<p>I recently stumbled across an implementation of the <a href="https://demonstrations.wolfram.com/AffineScalingInteriorPointMethod/">affine scaling</a> <a href="https://en.wikipedia.org/wiki/Interior_point_method">interior point method</a> for solving linear programs that I&rsquo;d coded up in R once upon a time. I&rsquo;m posting it here in case anyone else finds it useful. There&rsquo;s not a whole lot of thought given to efficiency or numerical stability, just a demonstration of the basic algorithm. Still, sometimes that&rsquo;s exactly what one wants.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>solve.affine <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">function</span>(A, rc, x, tolerance<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>^<span style="color:#ae81ff">-7</span>, R<span style="color:#f92672">=</span><span style="color:#ae81ff">0.999</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Affine scaling method</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">while </span>(T) {
</span></span><span style="display:flex;"><span>    X_diag <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">diag</span>(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Compute (A * X_diag^2 * A^t)-1 using Cholesky factorization.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># This is responsible for scaling the original problem matrix.</span>
</span></span><span style="display:flex;"><span>    q <span style="color:#f92672">&lt;-</span> A <span style="color:#f92672">%*%</span> X_diag<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">%*%</span> <span style="color:#a6e22e">t</span>(A)
</span></span><span style="display:flex;"><span>    q_inv <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">chol2inv</span>(<span style="color:#a6e22e">chol</span>(q))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># lambda = q * A * X_diag^2 * c</span>
</span></span><span style="display:flex;"><span>    lambda <span style="color:#f92672">&lt;-</span> q_inv <span style="color:#f92672">%*%</span> A <span style="color:#f92672">%*%</span> X_diag^2 <span style="color:#f92672">%*%</span> rc
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># c - A^t * lambda is used repeatedly</span>
</span></span><span style="display:flex;"><span>    foo <span style="color:#f92672">&lt;-</span> rc <span style="color:#f92672">-</span> <span style="color:#a6e22e">t</span>(A) <span style="color:#f92672">%*%</span> lambda
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># We converge as s goes to zero</span>
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">sqrt</span>(<span style="color:#a6e22e">sum</span>((X_diag <span style="color:#f92672">%*%</span> foo)^2))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Compute new x</span>
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">&lt;-</span> (x <span style="color:#f92672">+</span> R <span style="color:#f92672">*</span> X_diag^2 <span style="color:#f92672">%*%</span> foo <span style="color:#f92672">/</span> s)[,]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># If s is within our tolerance, stop.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">if </span>(<span style="color:#a6e22e">abs</span>(s) <span style="color:#f92672">&lt;</span> tolerance) break
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  x
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function accepts a matrix <code>A</code> which contains all technological coefficients for an LP, a vector <code>rc</code> containing its reduced costs, and an initial point <code>x</code> interior to the LP&rsquo;s feasible region. Optional arguments to the function include a tolerance, for detecting when the method is within an acceptable distance from the optimal point, and a value for <code>R</code>, which must be strictly between 0 and 1 and controls scaling.</p>
<p>The method works by rescaling the matrix <code>A</code> around the current solution <code>x</code>. It then computes a new <code>x</code> such that it remains feasible and interior, which is why <code>R</code> cannot be 0 or 1. It requires a feasible interior point to start and only projects to other feasible interior points, so the right hand side of the LP is not required (it is implicit from the starting point). The shadow prices for each iteration are captured in the vector lambda, so the gap between primal and dual solutions is easy to compute.</p>
<p>We run this function against a 3x3 LP with a known solution:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>max z = 5x1 + 4x2 + 3x3
</span></span><span style="display:flex;"><span>st      2x1 + 3x2 +  x3 &lt;=  5
</span></span><span style="display:flex;"><span>        4x1 +  x2 + 2x3 &lt;= 11
</span></span><span style="display:flex;"><span>        3x1 + 4x2 + 2x3 &lt;=  8
</span></span><span style="display:flex;"><span>        x1, x2, x3 &gt;= 0
</span></span></code></pre></div><p>The optimal solution to this LP is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>z  = 13
</span></span><span style="display:flex;"><span>x1 =  2
</span></span><span style="display:flex;"><span>x2 =  0
</span></span><span style="display:flex;"><span>x3 =  1
</span></span></code></pre></div><p>This problem can be run against the affine scaling function by defining A with all necessary slack variables, and using an arbitrary feasible interior point:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span>A <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">matrix</span>(<span style="color:#a6e22e">c</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>), nrow<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, byrow<span style="color:#f92672">=</span>T)
</span></span><span style="display:flex;"><span>rc <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">c</span>(<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>x  <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">c</span>(<span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">7.5</span>, <span style="color:#ae81ff">3.5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>solution <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">solve.affine</span>(A, rc, x)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">print</span>(solution)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">print</span>(<span style="color:#a6e22e">sum</span>(solution <span style="color:#f92672">*</span> rc))
</span></span></code></pre></div><p>This provides an output vector that is very close to the optimal primal solution shown above. Since interior point methods converge asymptotically to optimal solutions, it is important to note that we can only ever get (extremely) close to our final optimal objective and decision variable values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-r" data-lang="r"><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">print</span>(solution)
</span></span><span style="display:flex;"><span>[1] <span style="color:#ae81ff">1.999998e+00</span> <span style="color:#ae81ff">4.268595e-07</span> <span style="color:#ae81ff">1.000002e+00</span> <span style="color:#ae81ff">1.280579e-06</span> <span style="color:#ae81ff">1.000005e+00</span>
</span></span><span style="display:flex;"><span>[6] <span style="color:#ae81ff">1.280579e-06</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">print</span>(<span style="color:#a6e22e">sum</span>(solution <span style="color:#f92672">*</span> rc))
</span></span><span style="display:flex;"><span>[1] <span style="color:#ae81ff">13.00000</span>
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
  </channel>
</rss>
