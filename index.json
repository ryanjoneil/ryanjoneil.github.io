[{"content":"At a Nextmv tech talk a couple weeks ago, I showed a least absolute deviations (LAD) regression model using OR-Tools. This isn\u0026rsquo;t new \u0026ndash; I pulled the formulation from Rob Vanderbei\u0026rsquo;s \u0026ldquo;Local Warming\u0026rdquo; paper, and I\u0026rsquo;ve shown similar models at conference talks in the past using other modeling APIs and solvers.\nThere are a couple reasons I keep coming back to this problem. One is that it\u0026rsquo;s a great example of how to build a machine learning model using an optimization solver. Unless you have an optimization background, it\u0026rsquo;s probably not obvious you can do this. Building a regression or classification model with a solver directly is a great way to understand the model better. And you can customize it in interesting ways, like adding epsilon insensitivity.\nAnother is that least squares, while most commonly used regression form, has a fatal flaw: it isn\u0026rsquo;t robust to outliers in the input data. This is because least squares minimize the sum of squared residuals, as shown in the formulation below. Here, $A$ is an $m \\times n$ matrix of feature data, $b$ is a vector of observations to fit, and $x$ is a vector of coefficients the optimizer must find.\n$$ \\min f(x) = \\Vert Ax-b \\Vert^2 $$\nSince the objective function minimizes squared residuals, outliers have a much bigger impact than other data. LAD regression solves this by simply summing the values of the residuals as they are.\n$$ \\min f(x) = \\vert Ax-b \\vert $$\nSo why isn\u0026rsquo;t this used more? Simple \u0026ndash; least squares has a convenient analytical solution, while LAD requires an algorithm to solve. For instance, you can formulate LAD regression as a linear program, but now you need a solver.\n$$ \\begin{align*} \\min \\quad \u0026amp; 1\u0026rsquo;z \\\\ \\text{s.t.}\\ \\quad \u0026amp; z \\ge Ax - b \\\\ \u0026amp; z \\ge b - Ax \\end{align*} $$\nWhile I like using this example, it paints a rather negative picture of squaring. If it does funny things to solvers, is there any good reason to square? Thus I\u0026rsquo;ve been on the lookout for a practical example where squaring a variable or expression makes a model more useful.\nLuckily for me, Erwin Kalvelagen recently posted about using optimization to schedule team meetings. This is an application where minimizing squared values of overbooking can be beneficial \u0026ndash; it may be worse to be triple booked than double booked.\nI won\u0026rsquo;t recreate the reasoning behind Erwin\u0026rsquo;s post here. You can read his blog for that. What we\u0026rsquo;ll do is look at both the formulations in his post, along with a couple extras using Julia for code, JuMP for modeling, SCIP for optimization, and Gadfly for visualization. All model code and data are linked in the resources section at the end.\nMaximize attendance To start off, I built a new data set, which you can find in the resources section. This differentiates team membership between two types of employees: individual contributors (starting with ic in the data), who attend meetings for 1 or 2 teams, and managers (prefixed with mgr), who attend meetings to coordinate across multiple teams. We schedule meetings for 10 teams (prefix t) into 3 time slots (s).\nThe first model in Erwin\u0026rsquo;s post maximizes attendance. This means it tries to schedule team members for as many unique time slots as possible. It doesn\u0026rsquo;t consider overbooking.\n$$ \\begin{align*} \\max\\quad \u0026amp; \\sum_{i,s} y_{i,s} \\\\ \\text{s.t.}\\quad\u0026amp; \\sum_{s} x_{t,s} = 1 \u0026amp;\\quad\\forall\u0026amp;\\ t \u0026amp; \\text{schedule each team meeting once}\\\\ \u0026amp; y_{i,s} \\le \\sum_{t} m_{i,t}\\ x_{t,s} \u0026amp;\\quad\\forall\u0026amp;\\ i,s \u0026amp; \\text{individuals attend team meetings}\\\\ \u0026amp; x_{t,s} \\in \\{0,1\\} \u0026amp;\\quad\\forall\u0026amp;\\ t,s\\\\ \u0026amp; y_{i,s} \\in \\{0,1\\} \u0026amp;\\quad\\forall\u0026amp;\\ i,s \\end{align*} $$\nThis yields the following team schedule, with red representing a scheduled team meeting.\nIf we look at the manager schedules, we\u0026rsquo;ll see that every manager is completely booked. This makes sense. That\u0026rsquo;s what managers do, right? Go to meetings?\nMinimize overbooking The model gets more interesting once we account for overbooking. Erwin\u0026rsquo;s post has a model that minimizes overbooking, where overbooking is the number of additional meetings in a time slot. If a team member is double booked, that\u0026rsquo;s 1 overbooking. If they are triple booked, that\u0026rsquo;s 2 overbookings.\nSum of overbooking The second model in Erwin\u0026rsquo;s post minimizes the sum of all overbookings. He does this by adding a continuous c vector that only incurs value once a team member goes over a single meeting in a given time slot.\n$$ \\begin{align*} \\min\\quad \u0026amp; \\sum_{i,s} c_{i,s} \\\\ \\text{s.t.}\\quad\u0026amp; \\sum_{s} x_{t,s} = 1 \u0026amp;\\quad\\forall\u0026amp;\\ t \u0026amp; \\text{schedule each team meeting once}\\\\ \u0026amp; c_{i,s} \\ge \\sum_{t} m_{i,t}\\ x_{t,s} - 1 \u0026amp;\\quad\\forall\u0026amp;\\ i,s \u0026amp; \\text{measure overbooking}\\\\ \u0026amp; x_{t,s} \\in \\{0,1\\} \u0026amp;\\quad\\forall\u0026amp;\\ t,s\\\\ \u0026amp; c_{i,s} \\ge 0 \u0026amp;\\quad\\forall\u0026amp;\\ i,s \\end{align*} $$\nGiven our data this results in the following team schedule, which is probably not all that interesting. I\u0026rsquo;ll leave this visualization out from now on.\nWhere it gets interesting is plotting overbookings for the managers. Here we see that 3 manager time slots are triple booked (red), while 8 are double booked (gray).\nSum of squared overbooking Let\u0026rsquo;s say it\u0026rsquo;s worse to triple book (or, gasp, quadruple book) than to double book. How can the model account for this? One answer, if you have a MIQP-enabled solver, is to simply square the c values.\n$$ \\begin{align*} \\min\\quad \u0026amp; \\sum_{i,s} c_{i,s}^2 \\\\ \\text{s.t.}\\quad\u0026amp; \\sum_{s} x_{t,s} = 1 \u0026amp;\\quad\\forall\u0026amp;\\ t \u0026amp; \\text{schedule each team meeting once}\\\\ \u0026amp; c_{i,s} \\ge \\sum_{t} m_{i,t}\\ x_{t,s} - 1 \u0026amp;\\quad\\forall\u0026amp;\\ i,s \u0026amp; \\text{measure overbooking}\\\\ \u0026amp; x_{t,s} \\in \\{0,1\\} \u0026amp;\\quad\\forall\u0026amp;\\ t,s\\\\ \u0026amp; c_{i,s} \\ge 0 \u0026amp;\\quad\\forall\u0026amp;\\ i,s \\end{align*} $$\nThis completely eliminates triple booking, as shown below. No manager is worse off than being double booked, which seems normal given my experiences.\nThe problem with this is that the solver now takes a lot longer. It\u0026rsquo;s not bad for the data in this example, but if you try it with something larger you\u0026rsquo;ll see what I mean. You can find the data generator code in the resources section.\nConstrained bottleneck So how can we do something similar without the computational cost? One option is to continue using MILP formulations, but in the context of hierarchical optimization. This means splitting the model into two. First, we try to minimize the maximum overbookings for any team member (the bottleneck, if you will). This involves adding a variable $b$ representing that maximum.\n$$ b = \\max\\Bigl\\{\\sum_{t} m_{i,t}\\ x_{t,s} - 1 : i \\in I, s \\in S \\Bigr\\} $$\nNow we can simply minimize $b$ using a MILP instead of a MIQP.\n$$ \\begin{align*} \\min\\quad \u0026amp; b \\\\ \\text{s.t.}\\quad\u0026amp; \\sum_{s} x_{t,s} = 1 \u0026amp;\\quad\\forall\u0026amp;\\ t \u0026amp; \\text{schedule each team meeting once}\\\\ \u0026amp; b \\ge \\sum_{t} m_{i,t}\\ x_{t,s} - 1 \u0026amp;\\quad\\forall\u0026amp;\\ i,s \u0026amp; \\text{maximum overbooking}\\\\ \u0026amp; x_{t,s} \\in \\{0,1\\} \u0026amp;\\quad\\forall\u0026amp;\\ t,s \\end{align*} $$\nOnce we solve the first model, we get the minimal value of $b$, which we call $b^*$. We can simply use $b^*$ as an upper bound for overbookings in the second original model.\n$$ \\begin{align*} \\min\\quad \u0026amp; \\sum_{i,s} c_{i,s} \\\\ \\text{s.t.}\\quad\u0026amp; \\sum_{s} x_{t,s} = 1 \u0026amp;\\quad\\forall\u0026amp;\\ t \u0026amp; \\text{schedule each team meeting once}\\\\ \u0026amp; c_{i,s} \\ge \\sum_{t} m_{i,t}\\ x_{t,s} - 1 \u0026amp;\\quad\\forall\u0026amp;\\ i,s \u0026amp; \\text{measure overbooking}\\\\ \u0026amp; x_{t,s} \\in \\{0,1\\} \u0026amp;\\quad\\forall\u0026amp;\\ t,s\\\\ \u0026amp; 0 \\le c_{i,s} \\le b^* \u0026amp;\\quad\\forall\u0026amp;\\ i,s \\end{align*} $$\nAs we see below, this model also eliminates triple bookings, and it\u0026rsquo;s quite a bit faster to solve than the MIQP.\nResources main.go generates input data membership.csv contains input data maximize-attendance.jl MILP model minimize-overbooking.jl MILP model minimize-overbooking-squared.jl MIQP model minimize-bottleneck.jl hierarchical MILP models ","permalink":"https://ryanjoneil.github.io/posts/2023-11-26-reducing-overscheduling/","summary":"At a Nextmv tech talk a couple weeks ago, I showed a least absolute deviations (LAD) regression model using OR-Tools. This isn\u0026rsquo;t new \u0026ndash; I pulled the formulation from Rob Vanderbei\u0026rsquo;s \u0026ldquo;Local Warming\u0026rdquo; paper, and I\u0026rsquo;ve shown similar models at conference talks in the past using other modeling APIs and solvers.\nThere are a couple reasons I keep coming back to this problem. One is that it\u0026rsquo;s a great example of how to build a machine learning model using an optimization solver.","title":"📅 Reducing Overscheduling"},{"content":"I attended DPSOLVE 2023 recently and found lots of good inspiration for the next version of Nextmv\u0026rsquo;s Decision Diagram (DD) solver, Hop. It\u0026rsquo;s a few years old now, and we learned a lot applying it in the field. Hop formed the basis for our first routing models. While those models moved to a different structure in our latest routing code, the first version broke ground combining DDs with Adaptive Large Neighborhood Search (ALNS), and its use continues to grow organically.\nA feature I\u0026rsquo;d love for Hop is the ability to visualize DDs and monitor the search. That could work interactively, like Gecode\u0026rsquo;s GIST, or passively during the search process. This requires automatic generation of images representing potentially large diagrams. So I spent a few hours looking at graph rendering options for DDs.\nManual rendering We\u0026rsquo;ll start with examples of visualizations built by hand. These form a good standard for how we want DDs to look if we automate rendering. We\u0026rsquo;ll start with some examples from academic literature, look at some we\u0026rsquo;ve used in Nextmv presentations, and show an interesting example that embeds in Hugo, the popular static site generator I use for this blog.\nAll the literature on using Decision Diagrams (DD) for optimization that I\u0026rsquo;m aware of depicts DDs as top-down, layered, directed graphs (digraphs). Some of the diagrams we come across appear to be coded and rendered, while some are fussily created by hand with a diagramming tool.\nAcademia I believe most of of the examples we find in academic literature are coded by hand and rendered using the LaTeX TikZ package. Below is one of the first diagrams that newcomers to DDs encounter. It\u0026rsquo;s from Decision Diagrams for Optimization by Bergman et al, 2016.\nIt doesn\u0026rsquo;t matter here what model this represents. It\u0026rsquo;s a Binary Decision Diagram (BDD), which means that each variable can be $0$ or $1$. The BDD on the left is exact, while the BDD on the right is a relaxed version of the same.\nThere\u0026rsquo;s quite a bit going on, so it\u0026rsquo;s worth an explanation. Let\u0026rsquo;s look at the \u0026ldquo;exact\u0026rdquo; BDD on the left first.\nHorizontal layers group arcs with a binary variable (e.g. $x_1$, $x_2$). Arcs assign either the value $0$ or $1$ to their layer\u0026rsquo;s variable. Dotted lines assign $0$ while solid lines assign $1$. Arc labels specify their costs. The BDD searches for a longest (or shortest) path from the root node $r$ to the terminal node $t$. The \u0026ldquo;relaxed\u0026rdquo; BDD on the right overapproximates both the objective value and the set of feasible solutions of the exact BDD on the left.\nThe diagram is limited to a fixed width (2, in this case) at each layer. The achieve this, the DD merges exact nodes together. Thus, on the left of the relaxed BDD, there is a single node in which $x_2$ can be $0$ or $1$. Here\u0026rsquo;s another example of an exact BDD from the same book.\nIn this diagram, each node has a state. For example, the state of $r$ is $\\{1,2,3,4,5\\}$. If we start at the root node $r$ and assign $x_1 = 0$, we end up at node $u_1$ with state $\\{2,3,4,5\\}$.\nMost other academic literature about DDs uses images similar to these.\nNextmv We\u0026rsquo;ve rendered a number of DDs over the years at Nextmv. Most of these images demonstrate a concept instead of a particular model. We usually create them by hand in a diagramming tool like Whimsical, Lucidchart, or Excalidraw. I built the diagrams below by hand in Whimsical. I think the result is nice, if time consuming and fussy.\nThis is a representation of an exact DD. It doesn\u0026rsquo;t indicate whether this is a BDD or a Multivalued Decision Diagram (MDD). It doesn\u0026rsquo;t have any labels or variable names. It just shows what a DD search might look like in the abstract.\nThe restricted DD below is more involved. It addition to horizontal layers, it divides nodes into explored and deferred groups. Most of the examples I\u0026rsquo;ve seen mix different types of nodes, like exact and relaxed. I really like differentiating node types like this.\nIn this representation, deferred nodes are in Hop\u0026rsquo;s queue for later exploration. Thus they don\u0026rsquo;t connect to any child nodes yet. This is the kind of thing I\u0026rsquo;d like to generate with real diagrams during search so I can examine the state of the solver.\nMy favorite of my DD renderings so far is the next one. This shows a single-vehicle pickup-and-delivery problem. The arc labels are stops (e.g. 🐶, 🐱). The path the 🚗 follows to the terminal node is the route. The gray boxes group together nodes to merge based on state to reduce isomorphisms out of the diagram.\nWe also have some images like those in our post on expanders by hand. As you can see, coding these by hand gets tedious.\nGoAT TikZ is a program that renders manually coded graphics, while Whimsical is a WYSIWYG diagram editor. I like the Whimsical images a lot better \u0026ndash; they feel cleaner and easier to understand.\nHugo supports GoAT diagrams by default, so I tried that out too. Here is an arbitrary MDD with two layers. The $[[1,2],4]$ node is a relaxed node; it doesn\u0026rsquo;t really matter here what the label means.\nx x 1 2 0 1 0 [ [ 1 , 2 2 0 ] , 4 ] 1 3 0 0 I like the way GoAT renders this diagram. It\u0026rsquo;s very readable. Unfortunately, it isn\u0026rsquo;t easy to automate. Creating a GoAT diagram is like using ASCII as a WYSIWYG diagramming tool, as you can see from the code for that image.\n.-. .-----------+ o +-----------. | \u0026#39;+\u0026#39; | | | | v v v .-. .---------. .-. x1 | 0 | | [[1,2],4] | | 3 | \u0026#39;-\u0026#39; \u0026#39;----+----\u0026#39; \u0026#39;+\u0026#39; | | .------------+ | | | | v v v .--. .--. .---. x2 | 10 | | 20 | | 100 | \u0026#39;-+\u0026#39; \u0026#39;-+\u0026#39; \u0026#39;-+-\u0026#39; | | | | v | | .-. | \u0026#39;---------\u0026gt;| * |\u0026lt;----------\u0026#39; \u0026#39;-\u0026#39; Automated rendering Now we\u0026rsquo;ll look at a couple options for automatically generating visualizations of DDs. These convert descriptions of graphs into images.\nGraphviz Graphviz is the tried and true graph visualizer. It\u0026rsquo;s used in the Go pprof library for examining CPU and memory profiles, and lots of other places.\nGraphviz accepts a language called DOT. It uses different layout engines to convert input into a visual representation. The user doesn\u0026rsquo;t have control over node position. That\u0026rsquo;s the job of the layout engine.\nHere\u0026rsquo;s the same MDD as written in DOT. The start -\u0026gt; end lines specify arcs in the digraph. The subgraphs organize nodes into layers. We add a dotted border around each layer and a label to say which variable it assigns. There isn\u0026rsquo;t any way of vertically centering and horizontally aligning the layer labels, so I thought it make more sense this way.\ndigraph G { s1 [label = 0] s2 [label = \u0026#34;[[1,2],4]\u0026#34;] s3 [label = 3] s4 [label = 10] s5 [label = 20] s6 [label = 100] r -\u0026gt; s1 [label = 2] r -\u0026gt; s2 [label = 4] r -\u0026gt; s3 [label = 1] s2 -\u0026gt; s4 [label = 10] s2 -\u0026gt; s5 [label = 4] s3 -\u0026gt; s6 [label = 2] subgraph cluster_0 { label = \u0026#34;x1\u0026#34; labeljust = \u0026#34;l\u0026#34; style = \u0026#34;dotted\u0026#34; s1 s2 s3 } subgraph cluster_1 { label = \u0026#34;x2\u0026#34; labeljust = \u0026#34;l\u0026#34; style = \u0026#34;dotted\u0026#34; s4 s5 s6 } s4 -\u0026gt; t s5 -\u0026gt; t s6 -\u0026gt; t } The result is comprehensible if not very attractive. With some fiddling, it\u0026rsquo;s possible to improve things like the spacing around arc labels. I couldn\u0026rsquo;t figure out how to align the layer labels and boxes. It doesn\u0026rsquo;t seem possible to move the relaxed nodes into their own column either, but that limitation isn\u0026rsquo;t unique to Graphviz.\nMermaid Mermaid is a JavaScript library for diagramming and charting. One can use it on the web or, presumably, embed it in an application.\nMermaid is similar to Graphviz in many ways, but it supports more diagram types. The input for that MDD in Mermaid is a bit simpler. Labels go inside arcs (e.g. -- 2 --\u0026gt;), and there are more sensible rendering defaults.\ngraph TD start((( ))) stop((( ))) A(0) B(\u0026#34;[[1,2],4]\u0026#34;) C(3) D(10) E(20) F(100) start -- 2 --\u0026gt; A start -- 4 --\u0026gt; B start -- 1 --\u0026gt; C B -- 10 --\u0026gt; D B -- 4 --\u0026gt; E C -- 2 --\u0026gt; F D --\u0026gt; stop E --\u0026gt; stop F --\u0026gt; stop subgraph \u0026#34;x1 \u0026#34; A; B; C end subgraph \u0026#34;x2\u0026#34; D; E; F end The result has a lot of the same limitations as the Graphviz version, but it looks more like the GoAT version. The biggest problem, as we see below, is that it\u0026rsquo;s not possible to left-align the layer labels. They can be obscured by arcs.\ngraph TD start((( ))) stop((( ))) A(0) B(\"[[1,2],4]\") C(3) D(10) E(20) F(100) start -- 2 --\u003e A start -- 4 --\u003e B start -- 1 --\u003e C B -- 10 --\u003e D B -- 4 --\u003e E C -- 2 --\u003e F D --\u003e stop E --\u003e stop F --\u003e stop subgraph \"x1 \" A; B; C end subgraph \"x2\" D; E; F end This got me thinking that there isn\u0026rsquo;t a strong reason DDs have to progress downward layer by layer. They could just as easily go from left to right. If we change the opening line from graph TD to graph LR, then we get the following image.\ngraph LR start((( ))) stop((( ))) A(0) B(\"[[1,2],4]\") C(3) D(10) E(20) F(100) start -- 2 --\u003e A start -- 4 --\u003e B start -- 1 --\u003e C B -- 10 --\u003e D B -- 4 --\u003e E C -- 2 --\u003e F D --\u003e stop E --\u003e stop F --\u003e stop subgraph \"x1 \" A; B; C end subgraph \"x2\" D; E; F end I think that\u0026rsquo;s pretty nice for a generated image.\n","permalink":"https://ryanjoneil.github.io/posts/2023-09-13-visualizing-decision-diagrams/","summary":"I attended DPSOLVE 2023 recently and found lots of good inspiration for the next version of Nextmv\u0026rsquo;s Decision Diagram (DD) solver, Hop. It\u0026rsquo;s a few years old now, and we learned a lot applying it in the field. Hop formed the basis for our first routing models. While those models moved to a different structure in our latest routing code, the first version broke ground combining DDs with Adaptive Large Neighborhood Search (ALNS), and its use continues to grow organically.","title":"🖍 Visualizing Decision Diagrams"},{"content":"I\u0026rsquo;ve been a mostly absent blogger for the past few years. I could make excuses. They might sound like, \u0026ldquo;I was busy finishing my dissertation!\u0026rdquo; or \u0026ldquo;I founded a company and have a toddler!\u0026rdquo; or \u0026ldquo;The static site generator I used was abandoned!\u0026rdquo; Whatever they might be, these excuses would certainly end in exclamation points.\nBut, ultimately, for several years it just felt like blogging was dead. Its space was usurped by Tweets, LinkedIn hustle posts, long form Medium content aimed at attracting talent, and other content trends. RSS feeds dried up bit by bit. That beautiful structure somewhere between a college essay and an academic preprint mostly ceased to be. Sad times, indeed.\nThat trend seems to be reversing. I don\u0026rsquo;t know whether it\u0026rsquo;s the result of nudges from Substack, or that all the introverts in tech finally gave up baking pandemic, but there is a lot of good content out there again! Fire up your RSS aggregators and get reading.\nThis post is my own reboot of \u0026ldquo;adventures in optimization,\u0026rdquo; a blog I\u0026rsquo;ve written intermittently since 2009. Unfortunately, it will take some time to move over all my old posts to Hugo. I\u0026rsquo;ll do that slowly as I create new ones. For now, I\u0026rsquo;ve ported over a couple early posts and put together a list of the active blogs I\u0026rsquo;m gleefully catching up on.\nSee you soon!\nConstraint Applications Blog by Helmut Simonis Erling\u0026rsquo;s blog eugeneyan Harlan D. Harris Lil\u0026rsquo;Log Nathan Brixius Punk Rock Operations Research Shtetl-Optimized Timefold ","permalink":"https://ryanjoneil.github.io/posts/2023-09-07-blogging-is-back/","summary":"I\u0026rsquo;ve been a mostly absent blogger for the past few years. I could make excuses. They might sound like, \u0026ldquo;I was busy finishing my dissertation!\u0026rdquo; or \u0026ldquo;I founded a company and have a toddler!\u0026rdquo; or \u0026ldquo;The static site generator I used was abandoned!\u0026rdquo; Whatever they might be, these excuses would certainly end in exclamation points.\nBut, ultimately, for several years it just felt like blogging was dead. Its space was usurped by Tweets, LinkedIn hustle posts, long form Medium content aimed at attracting talent, and other content trends.","title":"🚀 Blogging is back, baby!"},{"content":"This is a running list of talks I\u0026rsquo;ve given and am scheduled to give. It probably isn\u0026rsquo;t exhaustive. Some of them have slides or videos available.\nUpcoming talks I don\u0026rsquo;t have any talks scheduled right now. Reach out to me on LinkedIn if you\u0026rsquo;re interested in scheduling one.\nPast talks 2023 December 6, 2023 - PyData Global 2023 - 📄 abstract, 🧑‍💻️ code, 💻 slides\nOrder up! How do I deliver it? Build on-demand logistics apps with Python, OR-Tools, and DecisionOps\nNovember 16, 2023 - Nextmv Videos - 🎥 video\nForecast, schedule, route: 3 starter models for on-demand logistics\nOctober 17, 2023 - INFORMS Annual Meeting - 📄 abstract\nAdapting to Change in On-Demand Delivery: Unpacking a Suite of Testing Methodologies\nSeptember 20, 2023 - DecisionCAMP 2023 - 📄 abstract, 💻 slides, 🎥 video\nDecision model, meet the real world: Testing optimization models for use in production environments\nAugust 27, 2023 - DPSOLVE 2023 - 💻 slides\nImplementing Decision Diagrams in Production Systems\nMay 11, 2023 - Nextmv Videos - 🎥 video\nSeveral people are optimizing: Collaborative workflows for decision model operations\nApril 18, 2023 - INFORMS Business Analytics Conference - 📄 abstract\nDecision Model, Meet Production: A Collaborative Workflow for Optimizing More Operations\nMarch 1, 2023 - Nextmv Videos - 🎥 video\nWhat are decision diagrams? How are they used to model and solve optimization problems?\nJanuary 18, 2023 - Nextmv Videos - 🎥 video\nIn conversation with Karla Hoffman\nAncient history October 5, 2020 - INFORMS Philadelphia Chapter - 🎥 video\nReal-Time Routing for On-Demand Delivery\nOctober 22, 2019 - INFORMS Annual Meeting - 💻 slides\nDecision Diagrams for Real-Time Routing\nJuly 6, 2017 - PyData Seattle 2017 - 📄 abstract, 🎥 video\nPractical Optimization for Stats Nerds\nMarch 5, 2017 - Data Science DC - 💻 slides\nPractical Optimization for Stats Nerds\nDecember 4, 2015 - PyData NYC 2015 - 💻 slides, 🎥 video\nOptimize your Docker Infrastructure with Python\nJuly 17, 2014 - IFORS 2014 - 📄 abstract, 💻 slides\nA MIP-Based Dual Bounding Technique for the Irregular Nesting Problem\nFebruary 19, 2010 - PyCon 2010 - 🎥 video\nOptimal Resource Allocation using Python\n","permalink":"https://ryanjoneil.github.io/speaking/","summary":"This is a running list of talks I\u0026rsquo;ve given and am scheduled to give. It probably isn\u0026rsquo;t exhaustive. Some of them have slides or videos available.\nUpcoming talks I don\u0026rsquo;t have any talks scheduled right now. Reach out to me on LinkedIn if you\u0026rsquo;re interested in scheduling one.\nPast talks 2023 December 6, 2023 - PyData Global 2023 - 📄 abstract, 🧑‍💻️ code, 💻 slides\nOrder up! How do I deliver it?","title":"💬 Some talk"},{"content":"I\u0026rsquo;m an desultory blogger and intermittent academic. Nonetheless, I like the research and writing process. Most of my current and old posts live here. Some of my other writings and collaborations are listed below.\nPapers, patents \u0026amp; preprints December 2023 - USPTO - 📄 patent\nPrediction of travel time and determination of prediction interval describes technology for predicting travel times for on-demand delivery platforms.\nJune 2023 - USPTO - 📄 patent\nRunners for optimization solvers and simulators describes technology for creating and executing Decision Diagram-based optimization solvers and state-based simulators in cloud environments.\nSeptember 2020 - Operations Research Forum - 📄 preprint\nMIPLIBing: Seamless Benchmarking of Mathematical Optimization Problems and Metadata Extensions presents a Python library that automatically downloads queried subsets from the current versions of MIPLIB, MINLPLib, and QPLIB, provides a centralized local cache across projects, and tracks the best solution values and bounds on record for each problem.\nMay 2019 - Operations Research Letters - 📄 preprint\nDecision diagrams for solving traveling salesman problems with pickup and delivery in real time explores the use of Multivalued Decision Diagrams and Assignment Problem inference duals for real-time optimization of TSPPDs.\nOctober 2018 - Optimization Online - 📄 preprint\nInteger Models for the Asymmetric Traveling Salesman Problem with Pickup and Delivery proposes a new ATSPPD model, new valid inequalities for the Sarin-Sherali-Bhootra ATSPPD, and studies the impact of relaxing complicating constraints in these.\nSeptember 2018 - Optimization Online - 📄 preprint\nExact Methods for Solving Traveling Salesman Problems with Pickup and Delivery in Real Time examines exact methods for solving TSPPDs with consolidation in real-time applications. It considers enumerative, Mixed Integer Programming, Constraint Programming, and hybrid optimization approaches under various time budgets.\nMarch 2018 - Optimization Online - 📄 preprint\nThe Meal Delivery Routing Problem introduces the MDRP to formalize and study an important emerging class of dynamic delivery operations. It also develops optimization-based algorithms tailored to solve the courier assignment (dynamic vehicle routing) and capacity management (offline shift scheduling) problems encountered in meal delivery operations.\nOther blogs December 19, 2023 - Nextmv Blog\nShift scheduling optimization: Generating shift types, planning for demand, and assigning workers\nApril 20, 2022 - Nextmv Blog\nYou need a solver. What is a solver?\nMarch 2, 2021 - Nextmv Blog\nBinaries are beautiful\nMarch 2, 2020 - Nextmv Blog\nHow Hop Hops\nSeptember 13, 2018 - Grubhub Bytes\nDecisions are first class citizens: an introduction to Decision Engineering\nJanuary 5, 2015 - The Yhat Blog\nCurrency Portfolio Optimization Using ScienceOps\nNovember 10, 2014 - The Yhat Blog\nHow Yhat Does Cloud Balancing: A Case Study\n","permalink":"https://ryanjoneil.github.io/writing/","summary":"I\u0026rsquo;m an desultory blogger and intermittent academic. Nonetheless, I like the research and writing process. Most of my current and old posts live here. Some of my other writings and collaborations are listed below.\nPapers, patents \u0026amp; preprints December 2023 - USPTO - 📄 patent\nPrediction of travel time and determination of prediction interval describes technology for predicting travel times for on-demand delivery platforms.\nJune 2023 - USPTO - 📄 patent","title":"📝 Some text"},{"content":" I build decision automation and optimization tools. This is a\nBy day, I am an operations research analyst a decision scientist, coder, and co-founder of Nextmv. I\u0026rsquo;m interested in hybrid optimization, decision diagrams, and mixed integer programming. My applications skew toward logistics for delivery platforms, with detours into cutting and packing.\nFor the past several years, I\u0026rsquo;ve worked in real-time optimization for on-demand delivery, scheduling, forecasting, and simulation. I did a MS in Operations Research by night at George Mason University, then a PhD in the same department under the advisement of Karla Hoffman.\nBy night, I am am amateur cellist, and a cat and early music enthusiast. I mentor a bit at the Roux Institute and help out Classical Uprising where I can.\n","permalink":"https://ryanjoneil.github.io/about/","summary":"I build decision automation and optimization tools. This is a\nBy day, I am an operations research analyst a decision scientist, coder, and co-founder of Nextmv. I\u0026rsquo;m interested in hybrid optimization, decision diagrams, and mixed integer programming. My applications skew toward logistics for delivery platforms, with detours into cutting and packing.\nFor the past several years, I\u0026rsquo;ve worked in real-time optimization for on-demand delivery, scheduling, forecasting, and simulation. I did a MS in Operations Research by night at George Mason University, then a PhD in the same department under the advisement of Karla Hoffman.","title":"🖖 Hi, I'm Ryan."},{"content":"Most of my work is proprietary, but some of it is open. Here are a few projects I\u0026rsquo;ve built or made significant contributions. I\u0026rsquo;ve also made significant contributions to projects such as PuLP, MIPLIBing, and MDRPlib.\nActive projects The Ruby Algebraic Modeling System is a simple modeling tool for formulating and solving MILPs in Ruby.\nap.cpp is an incremental primal-dual assignment problem solver written in C++. It can vastly improve propagation in hybrid optimization models that use AP relaxations. I use it within custom propagators in Gecode and in Decision Diagrams for solving the Traveling Salesman Problem with side constraints.\nap is a Go version of ap.cpp.\nTSPPD Hybrid Optimization Code and TSPPD Decision Diagram Code are both used in my dissertation. The former contains C++14 code for hybrid CP and MIP models for solving TSPPDs. The latter uses a hybridized Decision Diagram implementation with an Assignment Problem inference dual inside a branch-and-bound.\nTSPPDlib is a standard test set for TSPPDs. The instances are based on observed meal delivery data at Grubhub.\nDefunct projects python-zibopt was a Python interface to the SCIP Optimization Suite. This was no longer necessary once PySCIPOpt emerged.\nChute was a simple, lightweight tool for running discrete event simulations in Python.\nPyGEP was a simple library suitable for academic study of GEP (Gene Expression Programming) in Python 2.\n","permalink":"https://ryanjoneil.github.io/coding/","summary":"Most of my work is proprietary, but some of it is open. Here are a few projects I\u0026rsquo;ve built or made significant contributions. I\u0026rsquo;ve also made significant contributions to projects such as PuLP, MIPLIBing, and MDRPlib.\nActive projects The Ruby Algebraic Modeling System is a simple modeling tool for formulating and solving MILPs in Ruby.\nap.cpp is an incremental primal-dual assignment problem solver written in C++. It can vastly improve propagation in hybrid optimization models that use AP relaxations.","title":"🧑‍💻️ Some code"},{"content":"Note: This post was updated to work with NetworkX and for clarity.\nIt\u0026rsquo;s possible this will turn out like the day when Python 2.5 introduced [coroutines][coroutines]. At the time I was very excited. I spent several hours trying to convince my coworkers we should immediately abandon all our existing Java infrastructure and port it to finite state machines implemented using Python coroutines. After a day of hand waving over a proof of concept, we put that idea aside and went about our lives.\nSoon after, I left for a Python shop, but in the next half decade I still never found a good place to use this interesting feature.\nBut it doesn\u0026rsquo;t feel like that.\nAs I come to terms more with switching to Python 3.2, the futures module seems similarly exciting. I wish I\u0026rsquo;d had it years ago, and it\u0026rsquo;s almost reason in itself to upgrade from Python 2.7. Who cares if none of your libraries have been ported yet?\nThis library lets you take any function and distribute it over a process pool. To test that out, we\u0026rsquo;ll generate a bunch of random graphs and iterate over all their cliques.\nCode First, let\u0026rsquo;s generate some test data using the dense_gnm_random_graph function. Our data includes 1000 random graphs, each with 100 nodes and 100 * 100 edges.\nimport networkx as nx n = 100 graphs = [nx.dense_gnm_random_graph(n, n*n) for _ in range(1000)] Now we write a function iterate over all cliques in a given graph. NetworkX provides a find_cliques function which returns a generator. Iterating over them ensures we will run through the entire process of finding all cliques for a graph.\ndef iterate_cliques(g): for _ in nx.find_cliques(g): pass Now we just define two functions, one for running in serial and one for running in parallel using futures.\nfrom concurrent import futures def serial_test(graphs): for g in graphs: iterate_cliques(g) def parallel_test(graphs, max_workers): with futures.ProcessPoolExecutor(max_workers=max_workers) as executor: executor.map(iterate_cliques, graphs) Our __main__ simply generates the random graphs, samples from them, times both functions, and write CSV data to standard output.\nfrom csv import writer import random import sys import time if __name__ == \u0026#39;__main__\u0026#39;: out = writer(sys.stdout) out.writerow([\u0026#39;num graphs\u0026#39;, \u0026#39;serial time\u0026#39;, \u0026#39;parallel time\u0026#39;]) n = 100 graphs = [nx.dense_gnm_random_graph(n, n*n) for _ in range(1000)] # Run with a number of different randomly generated graphs for num_graphs in range(50, 1001, 50): sample = random.choices(graphs, k = num_graphs) start = time.time() serial_test(sample) serial_time = time.time() - start start = time.time() parallel_test(sample, 16) parallel_time = time.time() - start out.writerow([num_graphs, serial_time, parallel_time]) The output of this script shows that we get a fairly linear speedup to this code with little effort.\nI ran this on a machine with 8 cores and hyperthreading. Eyeballing the chart, it looks like the speedup is roughly 5x. My system monitor shows spikes on CPU usage across cores whenever the parallel test runs.\nResources Output data Full source listing ","permalink":"https://ryanjoneil.github.io/posts/2011-05-19-networkx-and-python-futures/","summary":"Note: This post was updated to work with NetworkX and for clarity.\nIt\u0026rsquo;s possible this will turn out like the day when Python 2.5 introduced [coroutines][coroutines]. At the time I was very excited. I spent several hours trying to convince my coworkers we should immediately abandon all our existing Java infrastructure and port it to finite state machines implemented using Python coroutines. After a day of hand waving over a proof of concept, we put that idea aside and went about our lives.","title":"🔮 NetworkX and Python Futures"},{"content":"I recently stumbled across an implementation of the affine scaling interior point method for solving linear programs that I\u0026rsquo;d coded up in R once upon a time. I\u0026rsquo;m posting it here in case anyone else finds it useful. There\u0026rsquo;s not a whole lot of thought given to efficiency or numerical stability, just a demonstration of the basic algorithm. Still, sometimes that\u0026rsquo;s exactly what one wants.\nsolve.affine \u0026lt;- function(A, rc, x, tolerance=10^-7, R=0.999) { # Affine scaling method while (T) { X_diag \u0026lt;- diag(x) # Compute (A * X_diag^2 * A^t)-1 using Cholesky factorization. # This is responsible for scaling the original problem matrix. q \u0026lt;- A %*% X_diag**2 %*% t(A) q_inv \u0026lt;- chol2inv(chol(q)) # lambda = q * A * X_diag^2 * c lambda \u0026lt;- q_inv %*% A %*% X_diag^2 %*% rc # c - A^t * lambda is used repeatedly foo \u0026lt;- rc - t(A) %*% lambda # We converge as s goes to zero s \u0026lt;- sqrt(sum((X_diag %*% foo)^2)) # Compute new x x \u0026lt;- (x + R * X_diag^2 %*% foo / s)[,] # If s is within our tolerance, stop. if (abs(s) \u0026lt; tolerance) break } x } This function accepts a matrix A which contains all technological coefficients for an LP, a vector rc containing its reduced costs, and an initial point x interior to the LP\u0026rsquo;s feasible region. Optional arguments to the function include a tolerance, for detecting when the method is within an acceptable distance from the optimal point, and a value for R, which must be strictly between 0 and 1 and controls scaling.\nThe method works by rescaling the matrix A around the current solution x. It then computes a new x such that it remains feasible and interior, which is why R cannot be 0 or 1. It requires a feasible interior point to start and only projects to other feasible interior points, so the right hand side of the LP is not required (it is implicit from the starting point). The shadow prices for each iteration are captured in the vector lambda, so the gap between primal and dual solutions is easy to compute.\nWe run this function against a 3x3 LP with a known solution:\nmax z = 5x1 + 4x2 + 3x3 st 2x1 + 3x2 + x3 \u0026lt;= 5 4x1 + x2 + 2x3 \u0026lt;= 11 3x1 + 4x2 + 2x3 \u0026lt;= 8 x1, x2, x3 \u0026gt;= 0 The optimal solution to this LP is:\nz = 13 x1 = 2 x2 = 0 x3 = 1 This problem can be run against the affine scaling function by defining A with all necessary slack variables, and using an arbitrary feasible interior point:\nA \u0026lt;- matrix(c( 2,3,1,1,0,0, 4,1,2,0,1,0, 3,4,2,0,0,1 ), nrow=3, byrow=T) rc \u0026lt;- c(5, 4, 3, 0, 0, 0) x \u0026lt;- c(0.5, 0.5, 0.5, 2, 7.5, 3.5) solution \u0026lt;- solve.affine(A, rc, x) print(solution) print(sum(solution * rc)) This provides an output vector that is very close to the optimal primal solution shown above. Since interior point methods converge asymptotically to optimal solutions, it is important to note that we can only ever get (extremely) close to our final optimal objective and decision variable values.\n\u0026gt; print(solution) [1] 1.999998e+00 4.268595e-07 1.000002e+00 1.280579e-06 1.000005e+00 [6] 1.280579e-06 \u0026gt; print(sum(solution * rc)) [1] 13.00000 ","permalink":"https://ryanjoneil.github.io/posts/2011-04-27-affine-scaling-in-r/","summary":"I recently stumbled across an implementation of the affine scaling interior point method for solving linear programs that I\u0026rsquo;d coded up in R once upon a time. I\u0026rsquo;m posting it here in case anyone else finds it useful. There\u0026rsquo;s not a whole lot of thought given to efficiency or numerical stability, just a demonstration of the basic algorithm. Still, sometimes that\u0026rsquo;s exactly what one wants.\nsolve.affine \u0026lt;- function(A, rc, x, tolerance=10^-7, R=0.","title":"👉 Affine Scaling in R"},{"content":"Note: This post was edited for clarity.\nFor the final JAPH in this series, I implemented a simple transpiler that converts a small subset of Scheme programs to equivalent Python programs. It starts with a Scheme program that prints 'just another scheme hacker'.\n(define (output x) (if (null? x) \u0026#34;\u0026#34; (begin (display (car x)) (if (null? (cdr x)) (display \u0026#34;\\n\u0026#34;) (begin (display \u0026#34; \u0026#34;) (output (cdr x))))))) (output (list \u0026#34;just\u0026#34; \u0026#34;another\u0026#34; \u0026#34;scheme\u0026#34; \u0026#34;hacker\u0026#34;)) The program then tokenizes that Scheme source, parses the token stream, and converts that into Python 3.\ndef output(x): if not x: \u0026#34;\u0026#34; else: print(x[0], end=\u0026#39;\u0026#39;) if not x[1:]: print(\u0026#34;\\n\u0026#34;, end=\u0026#39;\u0026#39;) else: print(\u0026#34; \u0026#34;, end=\u0026#39;\u0026#39;) output(x[1:]) output([\u0026#34;just\u0026#34;, \u0026#34;another\u0026#34;, \u0026#34;python\u0026#34;, \u0026#34;hacker\u0026#34;]) Finally it executes the resulting Python string using exec. Obfuscation is left as an exercise for the reader.\nimport re def tokenize(input): \u0026#39;\u0026#39;\u0026#39;Tokenizes an input stream into a list of recognizable tokens\u0026#39;\u0026#39;\u0026#39; token_res = ( r\u0026#39;\\(\u0026#39;, # open paren -\u0026gt; starts expression r\u0026#39;\\)\u0026#39;, # close paren -\u0026gt; ends expression r\u0026#39;\u0026#34;[^\u0026#34;]*\u0026#34;\u0026#39;, # quoted string (don\u0026#39;t support \\\u0026#34; yet) r\u0026#39;[\\w?]+\u0026#39; # atom ) return re.findall(r\u0026#39;(\u0026#39; + \u0026#39;|\u0026#39;.join(token_res) + \u0026#39;)\u0026#39;, input) def parse(stream): \u0026#39;\u0026#39;\u0026#39;Parses a token stream into a syntax tree\u0026#39;\u0026#39;\u0026#39; if not stream: return [] else: # Build a list of arguments (possibly expressions) at this level args = [] while True: # Get the next token try: x = stream.pop(0) except IndexError: return args # ( and ) control the level of the tree we\u0026#39;re at if x == \u0026#39;(\u0026#39;: args.append(parse(stream)) elif x == \u0026#39;)\u0026#39;: return args else: args.append(x) def compile(tree): \u0026#39;\u0026#39;\u0026#39;Compiles an Scheme Abstract Syntax Tree into near-Python\u0026#39;\u0026#39;\u0026#39; def compile_expr(indent, expr): indent += 1 lines = [] # these will have [(indent, statement), ...] structure while expr: # Two options: expr is a string like \u0026#34;\u0026#39;\u0026#34; or it is a list if isinstance(expr, str): return [( indent, expr.replace(\u0026#39;scheme\u0026#39;, \u0026#39;python\u0026#39;).replace(\u0026#39;\\n\u0026#39;, \u0026#39;\\\\n\u0026#39;) )] else: start = expr.pop(0) if start == \u0026#39;define\u0026#39;: signature = expr.pop(0) lines.append((indent, \u0026#39;def %s(%s):\u0026#39; % ( signature[0], \u0026#39;, \u0026#39;.join(signature[1:]) ) )) while expr: lines.extend(compile_expr(indent, expr.pop(0))) elif start == \u0026#39;if\u0026#39;: # We don\u0026#39;t support multi-clause conditionals yet clause = compile_expr(indent, expr.pop(0))[0][1] lines.append((indent, \u0026#39;if %s:\u0026#39; % clause)) if_true_lines = compile_expr(indent, expr.pop(0)) if_false_lines = compile_expr(indent, expr.pop(0)) lines.extend(if_true_lines) lines.append((indent, \u0026#39;else:\u0026#39;)) lines.extend(if_false_lines) elif start == \u0026#39;null?\u0026#39;: # Only supports conditionals of the form (null? foo) if isinstance(expr[0], str): condition = expr.pop(0) else: condition = compile_expr(indent, expr.pop(0))[0][1] return [(indent, \u0026#39;not %s\u0026#39; % condition)] elif start == \u0026#39;begin\u0026#39;: # This is just a series of statements, so don\u0026#39;t indent while expr: lines.extend(compile_expr(indent-1, expr.pop(0))) elif start == \u0026#39;display\u0026#39;: arguments = [] while expr: arguments.append( compile_expr(indent, expr.pop(0))[0][1] ) lines.append(( indent, \u0026#34;print(%s, end=\u0026#39;\u0026#39;)\u0026#34; % (\u0026#39;, \u0026#39;.join(arguments)) )) elif start == \u0026#39;car\u0026#39;: lines.append((indent, \u0026#39;%s[0]\u0026#39; % expr.pop(0))) elif start == \u0026#39;cdr\u0026#39;: lines.append((indent, \u0026#39;%s[1:]\u0026#39; % expr.pop(0))) elif start == \u0026#39;list\u0026#39;: arguments = [] while expr: arguments.append( compile_expr(indent, expr.pop(0))[0][1] ) lines.append((indent, \u0026#39;[%s]\u0026#39; % \u0026#39;, \u0026#39;.join(arguments))) else: # Assume this is a function call arguments = [] while expr: arguments.append( compile_expr(indent, expr.pop(0))[0][1] ) lines.append(( indent, \u0026#34;%s(%s)\u0026#34; % (start, \u0026#39;, \u0026#39;.join(arguments)) )) return lines return [compile_expr(-1, expr) for expr in tree] if __name__ == \u0026#39;__main__\u0026#39;: scheme = \u0026#39;\u0026#39;\u0026#39; (define (output x) (if (null? x) \u0026#34;\u0026#34; (begin (display (car x)) (if (null? (cdr x)) (display \u0026#34;\\n\u0026#34;) (begin (display \u0026#34; \u0026#34;) (output (cdr x))))))) (output (list \u0026#34;just\u0026#34; \u0026#34;another\u0026#34; \u0026#34;scheme\u0026#34; \u0026#34;hacker\u0026#34;)) \u0026#39;\u0026#39;\u0026#39; python = \u0026#39;\u0026#39; for expr in compile(parse(tokenize(scheme))): python += \u0026#39;\\n\u0026#39;.join([(\u0026#39; \u0026#39; * 4 * x[0]) + x[1] for x in expr]) + \u0026#39;\\n\\n\u0026#39; exec(python) ","permalink":"https://ryanjoneil.github.io/posts/2011-04-18-reformed-japhs-transpiler/","summary":"Note: This post was edited for clarity.\nFor the final JAPH in this series, I implemented a simple transpiler that converts a small subset of Scheme programs to equivalent Python programs. It starts with a Scheme program that prints 'just another scheme hacker'.\n(define (output x) (if (null? x) \u0026#34;\u0026#34; (begin (display (car x)) (if (null? (cdr x)) (display \u0026#34;\\n\u0026#34;) (begin (display \u0026#34; \u0026#34;) (output (cdr x))))))) (output (list \u0026#34;just\u0026#34; \u0026#34;another\u0026#34; \u0026#34;scheme\u0026#34; \u0026#34;hacker\u0026#34;)) The program then tokenizes that Scheme source, parses the token stream, and converts that into Python 3.","title":"🐪 Reformed JAPHs: Transpiler"},{"content":"Note: This post was edited for clarity.\nThis JAPH uses a Turing machine. The machine accepts any string that ends in '\\n' and allows side effects. This lets us print the value of the tape as it encounters each character. While the idea of using lambda functions as side effects in a Turing machine is a little bizarre on many levels, we work with what we have. And Python is multi-paradigmatic, so what the heck.\nimport re def turing(tape, transitions): # The tape input comes in as a string. We approximate an infinite # length tape via a hash, so we need to convert this to {index: value} tape_hash = {i: x for i, x in enumerate(tape)} # Start at 0 using our transition matrix index = 0 state = 0 while True: value = tape_hash.get(index, \u0026#39;\u0026#39;) # This is a modified Turing machine: it uses regexen # and has side effects. Oh well, I needed IO. for rule in transitions[state]: regex, next, direction, new_value, side_effect = rule if re.match(regex, value): # Terminal states if new_value in (\u0026#39;YES\u0026#39;, \u0026#39;NO\u0026#39;): return new_value tape_hash[index] = new_value side_effect(value) index += direction state = next break assert \u0026#39;YES\u0026#39; == turing(\u0026#39;just another python hacker\\n\u0026#39;, [ # This Turing machine recognizes the language of strings that end in \\n. # Regex rule, next state, left/right = -1/+1, new value, side effect. [ # State 0: [r\u0026#39;^[a-z ]$\u0026#39;, 0, +1, \u0026#39;\u0026#39;, lambda x: print(x, end=\u0026#39;\u0026#39;)], [r\u0026#39;^\\n$\u0026#39;, 1, +1, \u0026#39;\u0026#39;, lambda x: print(x, end=\u0026#39;\u0026#39;)], [r\u0026#39;^.*$\u0026#39;, 0, +1, \u0026#39;NO\u0026#39;, None], ], [ # State 1: [r\u0026#39;^$\u0026#39;, 1, -1, \u0026#39;YES\u0026#39;, None] ] ]) Obfuscation again consists of converting the above code into lambda functions using Y combinators. This is a nice programming exercise, so I\u0026rsquo;ve left it out of this post in case anyone wants to try. The Turing machine has to return 'YES' to indicate that it accepts the string, thus the assertion. Our final obfuscated JAPH is a single expression.\nassert\u0026#39;\u0026#39;\u0026#39;YES\u0026#39;\u0026#39;\u0026#39;==(lambda g:(lambda f:g(lambda arg:f(f)(arg)))(lambda f:g( lambda arg: f(f)(arg))))(lambda f: lambda q:[(lambda g:(lambda f:g(lambda arg:f(f)(arg)))(lambda f: g(lambda arg:f(f)(arg))))(lambda f: lambda x:(x [0][0]if x[0] and __import__(\u0026#39;re\u0026#39;).match(x[0][0][0],x[1])else f([x[0][1:] ,x[1]]))) ([q[3][q[1]],q[2].get(q[0],\u0026#39;\u0026#39;)])[4](q[2].get(q[0],\u0026#39;\u0026#39;)), (lambda g:(lambda f:g(lambda arg:f(f)(arg))) (lambda f:g(lambda arg:f(f)(arg))))( lambda f:lambda x:(x[0][0]if x[0] and __import__(\u0026#39;re\u0026#39;).match(x[0][0][0],x [1])else f([x[0][1:],x[1]])))([q[3][q[1]],q[2].get(q[0],\u0026#39;\u0026#39;)])[3]if(lambda g:(lambda f:g(lambda arg:f(f)(arg))) (lambda f:g(lambda arg:f(f)(arg))))( lambda f:lambda x:(x[0][0]if x[0]and __import__(\u0026#39;re\u0026#39;).match(x[0][0][0],x[ 1]) else f([x[0][1:],x[1]])))([q[3][q[1]],q[2].get(q[0],\u0026#39;\u0026#39;)])[3]in(\u0026#39;YES\u0026#39;, \u0026#39;NO\u0026#39;)else f([q[0]+(lambda g:(lambda f:g(lambda arg:f(f)(arg)))(lambda f:g (lambda arg:f(f)(arg))))(lambda f:lambda x:(x[0][0]if x[0]and __import__( \u0026#39;re\u0026#39;).match(x[0][0][0],x[1])else f([x[0][1:], x[1]])))([q[3][q[1]], q[2]. get(q[0],\u0026#39;\u0026#39;)])[2],(lambda g:(lambda f:g(lambda arg: f(f)(arg)))(lambda f: g(lambda arg:f(f)(arg))))(lambda f:lambda x:(x[0][0]if x[0]and __import__ (\u0026#39;re\u0026#39;).match(x[0][0][0],x[1])else f([x[0][1:], x[1]])))([q[3][q[1]],q[2]. get(q[0],\u0026#39;\u0026#39;)])[1],q[2],q[3]])][1])([0,0,{i:x for i,x in enumerate(\u0026#39;just \u0026#39; \u0026#39;another python hacker\\n\u0026#39;)}, [[[r\u0026#39;^[a-z ]$\u0026#39;,0,+1,\u0026#39;\u0026#39;,lambda x:print(x,end= \u0026#39;\u0026#39;)], [r\u0026#39;^\\n$\u0026#39;,1,+1,\u0026#39;\u0026#39;,lambda x:print(x, end=\u0026#39;\u0026#39;)],[r\u0026#39;^.*$\u0026#39;,0,+1,\u0026#39;\u0026#39;\u0026#39;NO\u0026#39;\u0026#39;\u0026#39;, lambda x:None]], [[r\u0026#39;\u0026#39;\u0026#39;^$\u0026#39;\u0026#39;\u0026#39;,+1,-1,\u0026#39;\u0026#39;\u0026#39;YES\u0026#39;\u0026#39;\u0026#39;, lambda x: None or None]]]]) ","permalink":"https://ryanjoneil.github.io/posts/2011-04-18-reformed-japhs-turing-machine/","summary":"Note: This post was edited for clarity.\nThis JAPH uses a Turing machine. The machine accepts any string that ends in '\\n' and allows side effects. This lets us print the value of the tape as it encounters each character. While the idea of using lambda functions as side effects in a Turing machine is a little bizarre on many levels, we work with what we have. And Python is multi-paradigmatic, so what the heck.","title":"🐪 Reformed JAPHs: Turing Machine"},{"content":"Note: This post was edited for clarity.\nAt this point, tricking python into printing strings via indirect means got a little boring. So I switched to obfuscating fundamental computer science algorithms. Here\u0026rsquo;s a JAPH that takes in a Huffman coded version of 'just another python hacker', decodes, and prints it.\n# Build coding tree def build_tree(scheme): if scheme.startswith(\u0026#39;*\u0026#39;): left, scheme = build_tree(scheme[1:]) right, scheme = build_tree(scheme) return (left, right), scheme else: return scheme[0], scheme[1:] def decode(tree, encoded): ret = \u0026#39;\u0026#39; node = tree for direction in encoded: if direction == \u0026#39;0\u0026#39;: node = node[0] else: node = node[1] if isinstance(node, str): ret += node node = tree return ret tree = build_tree(\u0026#39;*****ju*sp*er***yct* h**ka*no\u0026#39;)[0] print( decode(tree, bin(10627344201836243859174935587).lstrip(\u0026#39;0b\u0026#39;).zfill(103)) ) The decoding tree is like a LISP-style sequence of pairs. '*' represents a branch in the tree while other characters are leaf nodes. This looks like the following.\n( ( ( ( (\u0026#39;j\u0026#39;, \u0026#39;u\u0026#39;), (\u0026#39;s\u0026#39;, \u0026#39;p\u0026#39;) ), (\u0026#39;e\u0026#39;, \u0026#39;r\u0026#39;) ), ( ( (\u0026#39;y\u0026#39;, \u0026#39;c\u0026#39;), \u0026#39;t\u0026#39; ), (\u0026#39; \u0026#39;, \u0026#39;h\u0026#39;) ) ), ( (\u0026#39;k\u0026#39;, \u0026#39;a\u0026#39;), (\u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;) ) ) The actual Huffman coded version of our favorite string gets about 50% smaller represented in base-2.\n0000000001000100101011010111011101010111001000110110000110100001010111111110011001111010100110000100011 There\u0026rsquo;s a catch here, which is that this is hard to obfuscate unless we turn it into a single expression. This means that we have to convert build_tree and decode into lambda functions. Unfortunately, they are recursive and lambda functions recurse naturally. Fortunately, we can use Y combinators to get around the problem. These are worth some study since they will pop up again in future JAPHs.\nY = lambda g: ( lambda f: g(lambda arg: f(f)(arg))) (lambda f: g(lambda arg: f(f)(arg)) ) build_tree = Y( lambda f: lambda scheme: ( (f(scheme[1:])[0], f(f(scheme[1:])[1])[0]), f(f(scheme[1:])[1])[1 ] ) if scheme.startswith(\u0026#39;*\u0026#39;) else (scheme[0], scheme[1:]) ) decode = Y(lambda f: lambda x: x[3]+x[1] if not x[2] else ( f([x[0], x[0], x[2], x[3]+x[1]]) if isinstance(x[1], str) else ( f([x[0], x[1][0], x[2][1:], x[3]]) if x[2][0] == \u0026#39;0\u0026#39; else ( f([x[0], x[1][1], x[2][1:], x[3]]) ) ) )) tree = build_tree(\u0026#39;*****ju*sp*er***yct* h**ka*no\u0026#39;)[0] print( decode([ tree, tree, bin(10627344201836243859174935587).lstrip(\u0026#39;0b\u0026#39;).zfill(103), \u0026#39;\u0026#39; ]) ) The final version is a condensed (and expanded, oddly) version of the above.\nprint((lambda t,e,s:(lambda g:(lambda f:g(lambda arg:f(f)(arg)))(lambda f: g(lambda arg: f(f)(arg))))(lambda f:lambda x: x[3]+x[1]if not x[2]else f([ x[0],x[0],x[2],x[3]+x[1]])if isinstance(x[1],str)else f([x[0],x[1][0],x[2] [1:],x[3]])if x[2][0]==\u0026#39;0\u0026#39;else f([x[0],x[1][1],x[2][1:],x[3]]))([t,t,e,s]) )((lambda g:(lambda f:g(lambda arg:f(f)(arg)))(lambda f:g(lambda arg:f(f)( arg))))(lambda f:lambda p:((f(p[1:])[0],f(f(p[1:])[1])[0]),f(f(p[1:])[1])[ 1])if p.startswith(\u0026#39;*\u0026#39;)else(p[0],p[1:]))(\u0026#39;*****ju*sp*er***yct* h**ka*no\u0026#39;)[ 0],bin(10627344201836243859179756385-4820798).lstrip(\u0026#39;0b\u0026#39;).zfill(103),\u0026#39;\u0026#39;)) ","permalink":"https://ryanjoneil.github.io/posts/2011-04-14-reformed-japhs-huffman-coding/","summary":"Note: This post was edited for clarity.\nAt this point, tricking python into printing strings via indirect means got a little boring. So I switched to obfuscating fundamental computer science algorithms. Here\u0026rsquo;s a JAPH that takes in a Huffman coded version of 'just another python hacker', decodes, and prints it.\n# Build coding tree def build_tree(scheme): if scheme.startswith(\u0026#39;*\u0026#39;): left, scheme = build_tree(scheme[1:]) right, scheme = build_tree(scheme) return (left, right), scheme else: return scheme[0], scheme[1:] def decode(tree, encoded): ret = \u0026#39;\u0026#39; node = tree for direction in encoded: if direction == \u0026#39;0\u0026#39;: node = node[0] else: node = node[1] if isinstance(node, str): ret += node node = tree return ret tree = build_tree(\u0026#39;*****ju*sp*er***yct* h**ka*no\u0026#39;)[0] print( decode(tree, bin(10627344201836243859174935587).","title":"🐪 Reformed JAPHs: Huffman Coding"},{"content":"Note: This post was updated to work with Python 3.12. It may not work with different versions.\nHere\u0026rsquo;s a JAPH composed solely for effect. For each letter in 'just another python hacker' it loops over each the characters ' abcdefghijklmnopqrstuvwxyz', printing each. Between characters it pauses for 0.05 seconds, backing up and moving on to the next if it hasn\u0026rsquo;t reached the desired one yet. This achieves a sort of rolling effect by which the final string appears on our screen over time.\nimport string import sys import time letters = \u0026#39; \u0026#39; + string.ascii_lowercase for l in \u0026#39;just another python hacker\u0026#39;: for x in letters: print(x, end=\u0026#39;\u0026#39;) sys.stdout.flush() time.sleep(0.05) if x == l: break else: print(\u0026#39;\\b\u0026#39;, end=\u0026#39;\u0026#39;) print() We locate and print each letter in the string with a list comprehension. At the end we have an extra line of code (the eval statement) that gives us our newline.\n[[(lambda x,l:str(print(x,end=\u0026#39;\u0026#39;))+str(__import__(print. __doc__[print.__doc__.index(\u0026#39;stdout\u0026#39;) - 4:print.__doc__. index(\u0026#39;stdout\u0026#39;)-1]).stdout.flush()) + str(__import__(\u0026#39;\u0026#39;. join(reversed(\u0026#39;emit\u0026#39;))).sleep(0o5*1.01/0x64))+str(print( \u0026#39;\\b\u0026#39;,end=\u0026#39;\\x09\u0026#39;.strip())if x!=l else\u0026#39;*\u0026amp;#\u0026#39;))(x1,l1)for x1 in(\u0026#39;\\x20\u0026#39;+getattr(__import__(type(\u0026#39;phear\u0026#39;).__name__+\u0026#39;in\u0026#39; \u0026#39;g\u0026#39;),dir(__import__(type(\u0026#39;snarf\u0026#39;).__name__+\u0026#39;ing\u0026#39;))[15])) [:(\u0026#39;\\x20\u0026#39;+getattr(__import__(type(\u0026#39;smear\u0026#39;).__name__+\u0026#39;in\u0026#39; \u0026#39;g\u0026#39;),dir(__import__(type(\u0026#39;slurp\u0026#39;).__name__+\u0026#39;ing\u0026#39;))[15])) .index(l1)+1]]for l1 in\u0026#39;\u0026#39;\u0026#39;just another python hacker\u0026#39;\u0026#39;\u0026#39;] eval(\u0026#39;\u0026#39;\u0026#39;\\x20\\x09eval(\u0026#34;\\x20\\x09eval(\u0026#39;\\x20 print()\u0026#39;)\u0026#34;)\u0026#39;\u0026#39;\u0026#39;) ","permalink":"https://ryanjoneil.github.io/posts/2011-04-11-reformed-japhs-rolling-effect/","summary":"Note: This post was updated to work with Python 3.12. It may not work with different versions.\nHere\u0026rsquo;s a JAPH composed solely for effect. For each letter in 'just another python hacker' it loops over each the characters ' abcdefghijklmnopqrstuvwxyz', printing each. Between characters it pauses for 0.05 seconds, backing up and moving on to the next if it hasn\u0026rsquo;t reached the desired one yet. This achieves a sort of rolling effect by which the final string appears on our screen over time.","title":"🐪 Reformed JAPHs: Rolling Effect"},{"content":"Note: This post was updated to work with Python 3.12. It may not work with different versions.\nNo series of JAPHs would be complete without ROT13. This is the example through which aspiring Perl programmers learn to use tr and its synonym y. In Perl the basic ROT13 JAPH starts as:\n$foo = \u0026#39;whfg nabgure crey unpxre\u0026#39;; $foo =~ y/a-z/n-za-m/; print $foo; Python has nothing quite so elegant in its default namespace. However, this does give us the opportunity to explore a little used aspect of strings: the translate method. If we construct a dictionary of ordinals we can accomplish the same thing with a touch more effort.\nimport string table = { ord(x): ord(y) for x, y in zip( string.ascii_lowercase, string.ascii_lowercase[13:] + string.ascii_lowercase ) } print(\u0026#39;whfg nabgure clguba unpxre\u0026#39;.translate(table)) We obfuscate the construction of this translation dictionary and, for added measure, use getattr to find the print function off of __builtins__. This will likely only work in Python 3.2, since the order of attributes on __builtins__ matters.\ngetattr(vars()[list(filter(lambda _:\u0026#39;\\x5f\\x62\u0026#39;in _,dir ()))[0]], dir(vars()[list(filter(lambda _:\u0026#39;\\x5f\\x62\u0026#39;in _, dir()))[0]])[list(filter(lambda _:_ [1].startswith( \u0026#39;\\x70\\x72\u0026#39;),enumerate(dir(vars()[list(filter(lambda _: \u0026#39;\\x5f\\x62\u0026#39;in _,dir()))[0]]))))[0][0]])(getattr(\u0026#39;whfg \u0026#39; +\u0026#39;\u0026#39;\u0026#39;nabgure clguba unpxre\u0026#39;\u0026#39;\u0026#39;, dir(\u0026#39;0o52\u0026#39;)[0o116])({ _: (_-0o124) %0o32 +0o141 for _ in range(0o141, 0o173)})) ","permalink":"https://ryanjoneil.github.io/posts/2011-04-06-reformed-japhs-rot13/","summary":"Note: This post was updated to work with Python 3.12. It may not work with different versions.\nNo series of JAPHs would be complete without ROT13. This is the example through which aspiring Perl programmers learn to use tr and its synonym y. In Perl the basic ROT13 JAPH starts as:\n$foo = \u0026#39;whfg nabgure crey unpxre\u0026#39;; $foo =~ y/a-z/n-za-m/; print $foo; Python has nothing quite so elegant in its default namespace.","title":"🐪 Reformed JAPHs: ROT13"},{"content":"Here\u0026rsquo;s the second in my reformed JAPH series. It takes an anagram of 'just another python hacker' and converts it prior to printing. It sorts the anagram by the indices of another string, in order of their associated characters. This is sort of like a pre-digested Schwartzian transform.\nx = \u0026#39;upjohn tehran hectors katy\u0026#39; y = \u0026#39;1D0HG6JFO9P5ICKAM87B24NL3E\u0026#39; print(\u0026#39;\u0026#39;.join(x[i] for i in sorted(range(len(x)), key=lambda p: y[p]))) Obfuscation consists mostly of using silly machinations to construct the string we use to sort the anagram.\nprint(\u0026#39;\u0026#39;.join(\u0026#39;\u0026#39;\u0026#39;upjohn tehran hectors katy\u0026#39;\u0026#39;\u0026#39;[_]for _ in sorted(range (26),key=lambda p:(hex(29)[2:].upper()+str(3*3*3*3-3**4)+\u0026#39;HG\u0026#39;+str(sum( range(4)))+\u0026#39;JFO\u0026#39;+str((1+2)**(1+1))+\u0026#39;P\u0026#39;+str(35/7)[:1]+\u0026#39;i.c.k.\u0026#39;.replace( \u0026#39;.\u0026#39;,\u0026#39;\u0026#39;).upper()+\u0026#39;AM\u0026#39;+str(3**2*sum(range(5))-3)+hex(0o5444)[2:].replace (*\u0026#39;\\x62|\\x42\u0026#39;.split(\u0026#39;|\u0026#39;))+\u0026#39;NL\u0026#39;+hex(0o076).split(\u0026#39;x\u0026#39;)[1].upper())[p]))) ","permalink":"https://ryanjoneil.github.io/posts/2011-04-03-reformed-japhs-ridiculous-anagram/","summary":"Here\u0026rsquo;s the second in my reformed JAPH series. It takes an anagram of 'just another python hacker' and converts it prior to printing. It sorts the anagram by the indices of another string, in order of their associated characters. This is sort of like a pre-digested Schwartzian transform.\nx = \u0026#39;upjohn tehran hectors katy\u0026#39; y = \u0026#39;1D0HG6JFO9P5ICKAM87B24NL3E\u0026#39; print(\u0026#39;\u0026#39;.join(x[i] for i in sorted(range(len(x)), key=lambda p: y[p]))) Obfuscation consists mostly of using silly machinations to construct the string we use to sort the anagram.","title":"🐪 Reformed JAPHs: Ridiculous Anagram"},{"content":"Note: This post was edited for clarity.\nMany years ago, I was a Perl programmer. Then one day I became disillusioned at the progress of Perl 6 and decided to import this.\nThis seems to be a fairly common story for Perl to Python converts. While I haven\u0026rsquo;t looked back much, there are a number of things I really miss about perl (lower case intentional). I miss having value types in a dynamic language, magical and ill-advised use of cryptocontext, and sometimes even pseudohashes because they were inexcusably weird. A language that supports so many ideas out of the box enables an extended learning curve that lasts for many years. \u0026ldquo;Perl itself is the game.\u0026rdquo;\nMost of all I think I miss writing Perl poetry and JAPHs. Sadly, I didn\u0026rsquo;t keep any of those I wrote, and I\u0026rsquo;m not competent enough with the language anymore to write interesting ones. At the time I was intentionally distancing myself from a model that was largely implicit and based on archaic systems internals and moving to one that was (supposedly) explicit and simple.\nAfter switching to Python as my primary language, I used the following email signature in a nod to this change in orientation (intended for Python 2):\nprint \u0026#39;just another python hacker\u0026#39; Recently I\u0026rsquo;ve been experimenting with writing JAPHs in Python. I think of these as \u0026ldquo;reformed JAPHs.\u0026rdquo; They accomplish the same purpose as programming exercises but in a more restricted context. In some ways they are more challenging. Creativity can be difficult in a narrowly defined landscape.\nI have written a small series of reformed JAPHs which increase monotonically in complexity. Here is the first one, written in plain understandable Python 3.\nimport string letters = string.ascii_lowercase + \u0026#39; \u0026#39; indices = [ 9, 20, 18, 19, 26, 0, 13, 14, 19, 7, 4, 17, 26, 15, 24, 19, 7, 14, 13, 26, 7, 0, 2, 10, 4, 17 ] print(\u0026#39;\u0026#39;.join(letters[i] for i in indices)) This is fairly simple. Instead of explicitly embedding the string 'just another python hacker' in the program, we assemble it using the index of its letters in the string 'abcdefghijklmnopqrstuvwxyz '. We then obfuscate through a series of minor measures:\nInstead of calling the print function, we import sys and make a call to sys.stdout.write. We assemble string.lowercase + ' ' by joining together the character versions of its respective ordinal values (97 to 123 and 32). We join together the integer indices using 'l' and split that into a list. We apply ''' liberally and rely on the fact that python concatenates adjacent strings. Here\u0026rsquo;s the obfuscated version:\neval(\u0026#34;__import__(\u0026#39;\u0026#39;\u0026#39;\\x73\u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39;\\x79\u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39;\\x73\u0026#39;\u0026#39;\u0026#39;).sTdOuT\u0026#34;.lower() ).write(\u0026#39;\u0026#39;.join(map(lambda _:(list(map(chr,range(97,123)))+[chr( 32)])[int(_)],(\u0026#39;\u0026#39;\u0026#39;9l20l18l19\u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39;l26l0l13l14l19l7l4l17l26l15\u0026#39;\u0026#39;\u0026#39; \u0026#39;\u0026#39;\u0026#39;l24l19l7l14l1\u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39;\u0026#39;3l26l7l0l2l10l4l17\u0026#39;\u0026#39;\u0026#39;).split(\u0026#39;l\u0026#39;)))+\u0026#39;\\n\u0026#39;,) We could certainly do more, but that\u0026rsquo;s where I left this one. Stay tuned for the next JAPH.\n","permalink":"https://ryanjoneil.github.io/posts/2011-04-01-reformed-japhs-alphabetic-indexing/","summary":"Note: This post was edited for clarity.\nMany years ago, I was a Perl programmer. Then one day I became disillusioned at the progress of Perl 6 and decided to import this.\nThis seems to be a fairly common story for Perl to Python converts. While I haven\u0026rsquo;t looked back much, there are a number of things I really miss about perl (lower case intentional). I miss having value types in a dynamic language, magical and ill-advised use of cryptocontext, and sometimes even pseudohashes because they were inexcusably weird.","title":"🐪 Reformed JAPHs: Alphabetic Indexing"},{"content":"I hope you saw \u0026ldquo;China’s way to the top\u0026rdquo; on the Post\u0026rsquo;s website recently. It\u0026rsquo;s a very clear presentation of their statement and is certainly worth a look.\nSo say you\u0026rsquo;re an economist and you actually do need to produce a realistic estimate of when China\u0026rsquo;s GDP surpasses that of the USA. Can you use such an approach? Not really. There are several simplifying assumptions the Post made that are perfectly reasonable. However, if the goal is an analytical output from a highly random system such as GDP growth, one should not assume the inputs are fixed. (I\u0026rsquo;m not saying I have any gripe with their interactive. This post has a different purpose.)\nWhy is this? The short answer is that randomness in any system can change its output drastically from one run to the next. Even if the mean from a deterministic analysis is correct, it tells us nothing about the variance of our output. We really need a confidence interval of years when China is likely to overtake the USA.\nWe\u0026rsquo;ll move in the great tradition of all simulation studies. First we pepare our input. A CSV of GDP in current US dollars for both countries from 1960 to 2009 is available from the World Bank data files. We read this into a data frame and calculate their growth rates year over year. Note that the first value for growth has to be NA.\ngdp \u0026lt;- read.csv(\u0026#39;gdp.csv\u0026#39;) gdp$USA.growth \u0026lt;- rep(NA, length(gdp$USA)) gdp$China.growth \u0026lt;- rep(NA, length(gdp$China)) for (i in 2:length(gdp$USA)) { gdp$USA.growth[i] \u0026lt;- 100 * (gdp$USA[i] - gdp$USA[i-1]) / gdp$USA[i-1] gdp$China.growth[i] \u0026lt;- 100 * (gdp$China[i] - gdp$China[i-1]) / gdp$China[i-1] } We now analyze our inputs and assign probability distributions to the annual growth rates. In a full study this would involve comparing a number of different distributions and choosing the one that fits the input data best, but that\u0026rsquo;s well beyond the scope of this post. Instead, we\u0026rsquo;ll use the poor man\u0026rsquo;s way out: plot histograms and visually verify what we hope to be true, that the distributions are normal.\nAnd they pretty much are. That\u0026rsquo;s good enough for our purposes. Now all we need are the distribution parameters, which are mean and standard deviation for normal distributions.\n\u0026gt; mean(gdp$USA.growth[!is.na(gdp$USA.growth)]) [1] 7.00594 \u0026gt; sd(gdp$USA.growth[!is.na(gdp$USA.growth)]) [1] 2.889808 \u0026gt; mean(gdp$China.growth[!is.na(gdp$China.growth)]) [1] 9.90896 \u0026gt; sd(gdp$China.growth[!is.na(gdp$China.growth)]) [1] 10.5712\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; Now our input analysis is done. These are the inputs:\n$$ \\begin{align*} \\text{USA Growth} \u0026amp;\\sim \\mathcal{N}(7.00594, 2.889808^2)\\\\ \\text{China Growth} \u0026amp;\\sim \\mathcal{N}(9.90896, 10.5712^2) \\end{align*} $$\nThis should make the advantage of such an approach much more obvious. Compare the standard deviations for the two countries. China is a lot more likely to have negative GDP growth in any given year. They\u0026rsquo;re also more likely to have astronomical growth.\nWe now build and run our simulation study. The more times we run the simulation the tighter we can make our confidence interval (to a point), so we\u0026rsquo;ll pick a pretty big number somewhat arbitrarily. If we want to, we can be fairly scientific about determining how many iterations are necessary after we\u0026rsquo;ve done some runs, but we have to start somewhere.\nrepetitions \u0026lt;- 10000 This is the code for our simulation. For each iteration, it starts both countries at their 2009 GDPs. It then iterates, changing GDP randomly until China\u0026rsquo;s GDP is at least the same value as the USA\u0026rsquo;s. When that happens, it records the current year.\nresults \u0026lt;- rep(NA, repetitions) for (i in 1:repetitions) { usa \u0026lt;- gdp$USA[length(gdp$USA)] china \u0026lt;- gdp$China[length(gdp$China)] year \u0026lt;- gdp$Year[length(gdp$Year)] while (TRUE) { year \u0026lt;- year + 1 usa.growth \u0026lt;- rnorm(1, 7.00594, 2.889808) china.growth \u0026lt;- rnorm(1, 9.90896, 10.5712) usa \u0026lt;- usa * (1 + (usa.growth / 100)) china \u0026lt;- china * (1 + (china.growth / 100)) if (china \u0026gt;= usa) { results[i] \u0026lt;- year break } } } From the results vector we see that, given the data and assumptions for this model, China should surpass the USA in 2058. We also see that we can be 95% confident that the mean year this will happen is between 2057 and 2059. This is not quite the same as saying we are confident this will actually happen between those years. The result of our simulation is a probability distribution and we are discovering information about it.\n\u0026gt; mean(results) [1] 2058.494 \u0026gt; mean(results) + (sd(results) / sqrt(length(results)) * qnorm(0.025)) [1] 2057.873 \u0026gt; mean(results) + (sd(results) / sqrt(length(results)) * qnorm(0.975)) [1] 2059.114\u0026lt;/code\u0026gt;\u0026lt;/pre\u0026gt; So what\u0026rsquo;s wrong with this model? Well, we had to make a number of assumptions:\nWe assume we actually used the right data set. This was more of a how-to than a proper analysis, so that wasn\u0026rsquo;t too much of a concern. We assume future growth for the next 40-50 years resembles past growth from 1960-2009. This is a bit ridiculous, of course, but that\u0026rsquo;s the problem with forecasting. *We assume growth is normally distributed and that we don\u0026rsquo;t encounter heavy-tailed behaviors in our distributions. We assume each year\u0026rsquo;s growth is independent of the year before it. See the last exercise. Here are some good simulation exercises if you\u0026rsquo;re looking to do more:\nNote how the outputs are quite a bit different from the Post graphic. I expect that\u0026rsquo;s largely due to the inclusion of data back to 1960. Try running the simulation for yourself using just the past 10, 20, and 30 years and see how that changes the result.\u0026lt; Write a simulation to determine the probability China\u0026rsquo;s GDP surpasses the USA\u0026rsquo;s in the next 25 years. Now plot the mean GDP and 95% confidence intervals for each country per year. Assume that there are actually two distributions for growth for each country: one when the previous year had positive growth and another when it was negative. How does that change the output? ","permalink":"https://ryanjoneil.github.io/posts/2011-02-23-simulating-gdp-growth/","summary":"I hope you saw \u0026ldquo;China’s way to the top\u0026rdquo; on the Post\u0026rsquo;s website recently. It\u0026rsquo;s a very clear presentation of their statement and is certainly worth a look.\nSo say you\u0026rsquo;re an economist and you actually do need to produce a realistic estimate of when China\u0026rsquo;s GDP surpasses that of the USA. Can you use such an approach? Not really. There are several simplifying assumptions the Post made that are perfectly reasonable.","title":"📈 Simulating GDP Growth"},{"content":"Note: This post was updated to include an example data file.\nI thought it might be useful to follow up the last post with another one showing the same examples in R.\nR provides a function called lm, which is similar in spirit to NumPy\u0026rsquo;s linalg.lstsq. As you\u0026rsquo;ll see, lm\u0026rsquo;s interface is a bit more tuned to the concepts of modeling.\nWe begin by reading in the example CSV into a data frame:\nresponses \u0026lt;- read.csv(\u0026#39;example_data.csv\u0026#39;) responses respondent vanilla.love strawberry.love chocolate.love dog.love cat.love 1 Aylssa 9 4 9 9 9 2 Ben8 8 6 4 10 4 3 Cy 9 4 8 2 6 4 Eva 3 7 9 4 6 5 Lem 6 8 5 2 5 6 Louis 4 5 3 10 3 A data frame is sort of like a matrix, but with named columns. That is, we can refer to entire columns using the dollar sign. We are now ready to run least squares. We\u0026rsquo;ll create the model for predicting \u0026ldquo;dog love.\u0026rdquo; To create the \u0026ldquo;cat love\u0026rdquo; model, simply use that column name instead:\nfit1 \u0026lt;- lm( responses$dog.love ~ responses$vanilla.love + responses$strawberry.love + responses$chocolate.love ) The syntax for lm is a little off-putting at first. This call tells it to create a model for \u0026ldquo;dog love\u0026rdquo; with respect to (the ~) a function of the form offset + x1 * vanilla love + x2 * strawberry love + x3 * chocolate love. Note that the offset is conveniently implied when using lm, so this is the same as the second model we created in Python. Now that we\u0026rsquo;ve computed the coefficients for our \u0026ldquo;dog love\u0026rdquo; model, we can ask R about it:\nsummary(fit1) Call: lm(formula = responses$dog.love ~ responses$vanilla.love + responses$strawberry.love + responses$chocolate.love) Residuals: 1 2 3 4 5 6 3.1827 2.9436 -4.5820 0.8069 -1.9856 -0.3657 Coefficients: Estimate Std. Error t value Pr(\u0026gt;|t|) (Intercept) 20.9298 15.0654 1.389 0.299 responses$vanilla.love -0.2783 0.9934 -0.280 0.806 responses$strawberry.love -1.4314 1.5905 -0.900 0.463 responses$chocolate.love -0.7647 0.8214 -0.931 0.450 Residual standard error: 4.718 on 2 degrees of freedom Multiple R-squared: 0.4206,\tAdjusted R-squared: -0.4485 F-statistic: 0.484 on 3 and 2 DF, p-value: 0.7272 This gives us quite a bit of information, including the coefficients for our \u0026ldquo;dog love\u0026rdquo; model and various error metrics. You can find the offset and coefficients under the Estimate column above. We quickly verify this using R\u0026rsquo;s vectorized arithmetic:\n20.9298 - 0.2783 * responses$vanilla.love - 1.4314 * responses$strawberry.love - 0.7647 * responses$chocolate.love [1] 5.8172 7.0562 6.5819 3.1928 3.9853 10.3655 You\u0026rsquo;ll notice the model is essentially the same as the one we got from NumPy. Our next step is to add in the squared inputs. We do this by adding extra terms to the modeling formula. The I() function allows us to easily add additional operators to columns. That\u0026rsquo;s how we accomplish the squaring. We could alternatively add squared input values to the data frame, but using I() is more convenient and natural.\nfit2 \u0026lt;- lm(responses$dog.love ~ responses$vanilla.love + I(responses$vanilla.love^2) + responses$strawberry.love + I(responses$strawberry.love^2) + responses$chocolate.love + I(responses$chocolate.love^2)) summary(fit2) Call: lm(formula = responses$dog.love ~ responses$vanilla.love + I(responses$vanilla.love^2) + responses$strawberry.love + I(responses$strawberry.love^2) + responses$chocolate.love + I(responses$chocolate.love^2)) Residuals: ALL 6 residuals are 0: no residual degrees of freedom! Coefficients: (1 not defined because of singularities) Estimate Std. Error t value Pr(\u0026gt;|t|) (Intercept) -357.444 NaN NaN NaN responses$vanilla.love 72.444 NaN NaN NaN I(responses$vanilla.love^2) -6.111 NaN NaN NaN responses$strawberry.love 59.500 NaN NaN NaN I(responses$strawberry.love^2) -5.722 NaN NaN NaN responses$chocolate.love 7.000 NaN NaN NaN I(responses$chocolate.love^2) NA NA NA NA Residual standard error: NaN on 0 degrees of freedom Multiple R-squared: 1,\tAdjusted R-squared: NaN F-statistic: NaN on 5 and 0 DF, p-value: NA We can see that we get the same \u0026ldquo;dog love\u0026rdquo; model as produced by the third Python version of the last post. Again, we quickly verify that the output is the same (minus some rounding errors):\n-357.444 + 72.444 * responses$vanilla.love - 6.111 * responses$vanilla.love^2 + 59.5 * responses$strawberry.love - 5.722 * responses$strawberry.love^2 + 7 * responses$chocolate.love [1] 9.009 10.012 2.009 4.011 2.016 10.006 ","permalink":"https://ryanjoneil.github.io/posts/2011-02-16-data-fitting-2a-very-very-simple-linear-regression-in-r/","summary":"Note: This post was updated to include an example data file.\nI thought it might be useful to follow up the last post with another one showing the same examples in R.\nR provides a function called lm, which is similar in spirit to NumPy\u0026rsquo;s linalg.lstsq. As you\u0026rsquo;ll see, lm\u0026rsquo;s interface is a bit more tuned to the concepts of modeling.\nWe begin by reading in the example CSV into a data frame:","title":"🧐 Data Fitting 2a - Very, Very Simple Linear Regression in R"},{"content":"This post is based on a memo I sent to some former colleagues at the Post. I\u0026rsquo;ve edited it for use here since it fits well as the second in a series on simple data fitting techniques. If you\u0026rsquo;re among the many enlightened individuals already using regression analysis, then this post is probably not for you. If you aren\u0026rsquo;t, then hopefully this provides everything you need to develop rudimentary predictive models that yield surprising levels of accuracy.\nData For purposes of a simple working example, we have collected six records of input data over three dimensions with the goal of predicting two outputs. The input data are:\n$$ \\begin{align*} x_1 \u0026amp;= \\text{How much a respondent likes vanilla [0-10]}\\\\ x_2 \u0026amp;= \\text{How much a respondent likes strawberry [0-10]}\\\\ x_3 \u0026amp;= \\text{How much a respondent likes chocolate [0-10]} \\end{align*} $$\nOutput data consist of:\n$$ \\begin{align*} b_1 \u0026amp;= \\text{How much a respondent likes dogs [0-10]}\\\\ b_2 \u0026amp;= \\text{How much a respondent likes cats [0-10]} \\end{align*} $$\nBelow are anonymous data collected from a random sample of people.\nrespondent vanilla ❤️ strawberry ❤️ chocolate ❤️ dog ❤️ cat ❤️ Alyssa P Hacker 9 4 9 9 8 Ben Bitdiddle 8 6 4 10 4 Cy D. Fect 9 4 8 2 6 Eva Lu Ator 3 7 9 4 6 Lem E. Tweakit 6 8 5 2 5 Louis Reasoner 4 5 3 10 3 Our input is in three dimensions. Each output requires its own model, so we\u0026rsquo;ll have one for dogs and one for cats. We\u0026rsquo;re looking for functions, dog(x) and cat(x), that can predict $b_1$ and $b_2$ based on given values of $x_1$, $x_2$, and $x_3$.\nModel 1 For both models we want to find parameters that minimize their squared residuals (read: errors). There\u0026rsquo;s a number of names for this. Optimization folks like to think of it as unconstrained quadratic optimization, but it\u0026rsquo;s more common to call it least squares or linear regression. It\u0026rsquo;s not necessary to entirely understand why for our purposes, but the function that minimizes these errors is:\n$$\\beta = ({A^t}A)^{-1}{A^t}b$$\nThis is implemented for you in the numpy.linalg Python package, which we\u0026rsquo;ll use for examples. Much more information than you probably want can be found here.\nBelow is a first stab at a Python version. It runs least squares against our input and output data exactly as they are. You can see the matrix $A$ and outputs $b_1$ and $b_2$ (dog and cat love, respectively) are represented just as they are in the table.\n# Version 1: No offset, no squared inputs import numpy A = numpy.vstack([ [9, 4, 9], [8, 6, 4], [9, 4, 8], [3, 7, 9], [6, 8, 5], [4, 5, 3] ]) b1 = numpy.array([9, 10, 2, 4, 2, 10]) b2 = numpy.array([9, 4, 6, 6, 5, 3]) print(\u0026#39;dog ❤️:\u0026#39;, numpy.linalg.lstsq(A, b1, rcond=None)[0]) print(\u0026#39;cat ❤️:\u0026#39;, numpy.linalg.lstsq(A, b2, rcond=None)[0]) # Output: # dog ❤️: [0.72548294 0.53045642 -0.29952361] # cat ❤️: [2.36110929e-01 2.61934385e-05 6.26892476e-01] The resulting model is:\ndog(x) = 0.72548294 * x1 + 0.53045642 * x2 - 0.29952361 * x3 cat(x) = 2.36110929e-01 * x1 + 2.61934385e-05 * x2 + 6.26892476e-01 * x3 The coefficients before our variables correspond to beta in the formula above. Errors between observed and predicted data, shown below, are calculated and summed. For these six records, dog(x) has a total error of 20.76 and cat(x) has 3.74. Not great.\nrespondent predicted b1 b1 error predicted b2 b2 error Alyssa P Hacker 5.96 3.04 7.77 1.23 Ben Bitdiddle 7.79 2.21 4.40 0.40 Cy D. Fect 6.25 4.25 7.14 1.14 Eva Lu Ator 3.19 0.81 6.35 0.35 Lem E. Tweakit 7.10 5.10 4.55 0.45 Louis Reasoner 4.66 5.34 2.83 0.17 Total error: 20.76 3.74 Model 2 One problem with this model is that dog(x) and cat(x) are forced to pass through the origin. (Why is that?) We can improve it somewhat if we add an offset. This amounts to prepending 1 to every row in $A$ and adding a constant to the resulting functions. You can see the very slight difference between the code for this model and that of the previous:\n# Version 2: Offset, no squared inputs import numpy A = numpy.vstack([ [1, 9, 4, 9], [1, 8, 6, 4], [1, 9, 4, 8], [1, 3, 7, 9], [1, 6, 8, 5], [1, 4, 5, 3] ]) print(\u0026#39;dog ❤️:\u0026#39;, numpy.linalg.lstsq(A, b1, rcond=None)[0]) print(\u0026#39;cat ❤️:\u0026#39;, numpy.linalg.lstsq(A, b2, rcond=None)[0]) # Output: # dog ❤️: [20.92975427 -0.27831197 -1.43135684 -0.76469017] # cat ❤️: [-0.31744124 0.25133547 0.02978098 0.63394765] This yields the seconds version of our models:\ndog(x) = 20.92975427 - 0.27831197 * x1 - 1.43135684 * x2 - 0.76469017 * x3 cat(x) = -0.31744124 + 0.25133547 * x1 + 0.02978098 * x2 + 0.63394765 * x3 These models provide errors of 13.87 and 3.79. A little better on the dog side, but still not quite usable.\nrespondent predicted b1 b1 error predicted b2 b2 error Alyssa P Hacker 5.82 3.18 7.77 1.23 Ben Bitdiddle 7.06 2.94 4.41 0.41 Cy D. Fect 6.58 4.58 7.14 1.14 Eva Lu Ator 3.19 0.81 6.35 0.35 Lem E. Tweakit 3.99 1.99 4.60 0.40 Louis Reasoner 10.37 0.37 2.74 0.26 Total error: 13.87 3.79 Model 3 The problem is that dog(x) and cat(x) are linear functions. Most observed data don\u0026rsquo;t conform to straight lines. Take a moment and draw the line $f(x) = x$ and the curve $f(x) = x^2$. The former makes a poor approximation of the latter.\nMost of the time, people just use squares of the input data to add curvature to their models. We do this in our next version of the code by just adding squares of the input row values to our $A$ matrix. Everything else is the same. (In reality, you can add any function of the input data you feel best models the data, if you understand it well enough.)\n# Version 3: Offset with squared inputs import numpy A = numpy.vstack([ [1, 9, 9**2, 4, 4**2, 9, 9**2], [1, 8, 8**2, 6, 6**2, 4, 4**2], [1, 9, 9**2, 4, 4**2, 8, 8**2], [1, 3, 3**2, 7, 7**2, 9, 9**2], [1, 6, 6**2, 8, 8**2, 5, 5**2], [1, 4, 4**2, 5, 5**2, 3, 3**2] ]) b1 = numpy.array([9, 10, 2, 4, 2, 10]) b2 = numpy.array([9, 4, 6, 6, 5, 3]) print(\u0026#39;dog ❤️:\u0026#39;, numpy.linalg.lstsq(A, b1, rcond=None)[0]) print(\u0026#39;cat ❤️:\u0026#39;, numpy.linalg.lstsq(A, b2, rcond=None)[0]) # dog ❤️: [1.29368307 7.03633306 -0.44795498 9.98093332 # -0.75689575 -19.00757486 1.52985734] # cat ❤️: [0.47945896 5.30866067 -0.39644128 -1.28704188 # 0.12634295 -4.32392606 0.43081918] This gives us our final version of the model:\ndog(x) = 1.29368307 + 7.03633306 * x1 - 0.44795498 * x1**2 + 9.98093332 * x2 - 0.75689575 * x2**2 - 19.00757486 * x3 + 1.52985734 * x3**2 cat(x) = 0.47945896 + 5.30866067 * x1 - 0.39644128 * x1**2 - 1.28704188 * x2 + 0.12634295 * x2**2 - 4.32392606 * x3 + 0.43081918 * x3**2 Adding curvature to our model eliminates all perceived error, at least within 1e-16. This may seem unbelievable, but when you consider that we only have six input records, it isn\u0026rsquo;t really.\nrespondent predicted b1 b1 error predicted b2 b2 error Alyssa P Hacker 9 0 9 0 Ben Bitdiddle 10 0 4 0 Cy D. Fect 2 0 6 0 Eva Lu Ator 4 0 6 0 Lem E. Tweakit 2 0 5 0 Louis Reasoner 10 0 3 0 Total error: 0 0 It should be fairly obvious how one can take this and extrapolate to much larger models. I hope this is useful and that least squares becomes an important part of your lives.\n","permalink":"https://ryanjoneil.github.io/posts/2011-02-15-data-fitting-2-very-very-simple-linear-regression-in-python/","summary":"This post is based on a memo I sent to some former colleagues at the Post. I\u0026rsquo;ve edited it for use here since it fits well as the second in a series on simple data fitting techniques. If you\u0026rsquo;re among the many enlightened individuals already using regression analysis, then this post is probably not for you. If you aren\u0026rsquo;t, then hopefully this provides everything you need to develop rudimentary predictive models that yield surprising levels of accuracy.","title":"🧐 Data Fitting 2 - Very, Very Simple Linear Regression in Python"},{"content":"Consider this scenario: You run a contest that accepts votes from the general Internet population. In order to encourage user engagement, you record any and all votes into a database over several days, storing nothing more than the competitor voted for, when each vote is cast, and a cookie set on the voter\u0026rsquo;s computer along with their apparent IP addresses. If a voter already has a recorded cookie set they are denied subsequent votes. This way you can avoid requiring site registration, a huge turnoff for your users. Simple enough.\nUnfortunately, some of the competitors are wily and attached to the idea of winning. They go so far as programming or hiring bots to cast thousands of votes for them. Your manager wants to know which votes are real and which ones are fake Right Now. Given very limited time, and ignoring actions that you could have taken to avoid the problem, how can you tell apart sets of good votes from those that shouldn\u0026rsquo;t be counted?\nOne quick-and-dirty option involves comparing histograms of interarrival times for sets of votes. Say you\u0026rsquo;re concerned that all the votes during a particular period of time or from a given IP address might be fraudulent. Put all the vote times you\u0026rsquo;re concerned about into a list, sort them, and compute their differences:\n# times is a list of datetime instances from vote records times.sort(reversed=True) interarrivals = [y-x for x, y in zip(times, times[1:]] Now use matplotlib to display a histogram of these. Votes that occur naturally are likely to resemble an exponential distribution in their interarrival times. For instance, here are interarrival times for all votes received in a contest:\nThis subset of votes is clearly fraudulent, due to the near determinism of their interarrival times. This is most likely caused by the voting bot not taking random sleep intervals during voting. It casts a vote, receives a response, clears its cookies, and repeats:\nThese votes, on the other hand, are most likely legitimate. They exhibit a nice Erlang shape and appear to have natural interarrival times that one would expect:\nOf course this method is woefully inadequate for rigorous detection of voting fraud. Ideally one would find a method to compute the probability that a set of votes is generated by a bot. This is enough to inform quick, ad hoc decisions though.\n","permalink":"https://ryanjoneil.github.io/posts/2010-11-30-off-the-cuff-voter-fraud-detection/","summary":"Consider this scenario: You run a contest that accepts votes from the general Internet population. In order to encourage user engagement, you record any and all votes into a database over several days, storing nothing more than the competitor voted for, when each vote is cast, and a cookie set on the voter\u0026rsquo;s computer along with their apparent IP addresses. If a voter already has a recorded cookie set they are denied subsequent votes.","title":"🗳 Off the Cuff Voter Fraud Detection"},{"content":"Note: This post was updated to work with Python 3 and PySCIPOpt. The original version used Python 2 and python-zibopt.\nData fitting is one of those tasks that everyone should have at least some exposure to. Certainly developers and analysts will benefit from a working knowledge of its fundamentals and their implementations. However, in my own reading I\u0026rsquo;ve found it difficult to locate good examples that are simple enough to pick up quickly and come with accompanying source code.\nThis article commences an ongoing series introducing basic data fitting techniques. With any luck they won\u0026rsquo;t be overly complex, while still being useful enough to get the point across with a real example and real data. We\u0026rsquo;ll start with a binary classification problem: presented with a series of records, each containing a set number of input values describing it, determine whether or not each record exhibits some property.\nModel We\u0026rsquo;ll use the cancer1.dt data from the proben1 set of test cases, which you can download here. Each record starts with 9 data points containing physical characteristics of a tumor. The second to last data point contains 1 if a tumor is benign and 0 if it is malignant. We seek to find a linear function we can run on an arbitrary record that will return a value greater than zero if that record\u0026rsquo;s tumor is predicted to be benign and less than zero if it is predicted to be malignant. We will train our linear model on the first 350 records, and test it for accuracy on the remaining rows.\nThis is similar to the data fitting problem found in Chvatal. Our inputs consist of a matrix of observed data, $A$, and a vector of classifications, $b$. In order to classify a record, we require another vector $x$ such that the dot product of $x$ and that record will be either greater or less than zero depending on its predicted classification.\nA couple points to note before we start:\nMost observed data are noisy. This means it may be impossible to locate a hyperplane that cleanly separates given records of one type from another. In this case, we must resort to finding a function that minimizes our predictive error. For the purposes of this example, we\u0026rsquo;ll minimize the sum of the absolute values of the observed and predicted values. That is, we seek $x$ such that we find $min \\sum_i{|a_i^T x-b_i|}$.\nThe slope-intercept form of a line, $f(x)=m^T x+b$, contains an offset. It should be obvious that this is necessary in our model so that our function isn\u0026rsquo;t required to pass through the origin. Thus, we\u0026rsquo;ll be adding an extra variable with the coefficient of 1 to represent our offset value.\nIn order to model this, we use two linear constraints for each absolute value. We minimize the sum of these. Our Linear Programming model thus looks like:\n$$ \\begin{align*} \\min\\quad \u0026amp; z = x_0 + \\sum_i{v_i}\\\\ \\text{s.t.}\\quad\u0026amp; v_i \\geq x_0 + a_i^\\intercal x - 1 \u0026amp;\\quad\\forall\u0026amp;\\quad\\text{benign tumors}\\\\ \u0026amp; v_i \\geq 1 - x_0 - a_i^\\intercal x \u0026amp;\\quad\\forall\u0026amp;\\quad\\text{benign tumors}\\\\ \u0026amp; v_i \\geq x_0 + a_i^\\intercal x - (-1) \u0026amp;\\quad\\forall\u0026amp;\\quad\\text{malignant tumors}\\\\ \u0026amp; v_i \\geq -1 - x_0 - a_i^\\intercal x \u0026amp;\\quad\\forall\u0026amp;\\quad\\text{malignant tumors} \\end{align*} $$\nCode In order to do this in Python, we use SCIP and SoPlex. We start by setting constants for benign and malignant outputs and providing a function to read in the training and testing data sets.\n# Preferred output values for tumor categories BENIGN = 1 MALIGNANT = -1 def read_proben1_cancer_data(filename, train_size): \u0026#39;\u0026#39;\u0026#39;Loads a proben1 cancer file into train \u0026amp; test sets\u0026#39;\u0026#39;\u0026#39; # Number of input data points per record DATA_POINTS = 9 train_data = [] test_data = [] with open(filename) as infile: # Read in the first train_size lines to a training data list, and the # others to testing data. This allows us to test how general our model # is on something other than the input data. for line in infile.readlines()[7:]: # skip header line = line.split() # Records = offset (x0) + remaining data points input = [float(x) for x in line[:DATA_POINTS]] output = BENIGN if line[-2] == \u0026#39;1\u0026#39; else MALIGNANT record = {\u0026#39;input\u0026#39;: input, \u0026#39;output\u0026#39;: output} # Determine what data set to put this in if len(train_data) \u0026gt;= train_size: test_data.append(record) else: train_data.append(record) return train_data, test_data The next function implements the LP model described above using SoPlex and SCIP. It minimizes the sum of residuals for each training record. This amounts to summing the absolute value of the difference between predicted and observed output data. The following function takes in input and observed output data and returns a list of coefficients. Our resulting model consists of taking the dot product of an input record and these coefficients. If the result is greater than or equal to zero, that record is predicted to be a benign tumor, otherwise it is predicted to be malignant.\nfrom pyscipopt import Model def train_linear_model(train_data): \u0026#39;\u0026#39;\u0026#39; Accepts a set of input training data with known output values. Returns a list of coefficients to apply to arbitrary records for purposes of binary categorization. \u0026#39;\u0026#39;\u0026#39; # Make sure we have at least one training record. assert len(train_data) \u0026gt; 0 num_variables = len(train_data[0][\u0026#39;input\u0026#39;]) # Variables are coefficients in front of the data points. It is important # that these be unrestricted in sign so they can take negative values. m = Model() x = [m.addVar(f\u0026#39;x{i}\u0026#39;, lb=None) for i in range(num_variables)] # Residual for each data row residuals = [m.addVar(lb=None, ub=None) for _ in train_data] for r, d in zip(residuals, train_data): # r will be the absolute value of the difference between observed and # predicted values. We can model absolute values such as r \u0026gt;= |foo| as: # # r \u0026gt;= foo # r \u0026gt;= -foo m.addCons(sum(x * y for x, y in zip(x, d[\u0026#39;input\u0026#39;])) + r \u0026gt;= d[\u0026#39;output\u0026#39;]) m.addCons(sum(x * y for x, y in zip(x, d[\u0026#39;input\u0026#39;])) - r \u0026lt;= d[\u0026#39;output\u0026#39;]) # Find and return coefficients that min sum of residuals. m.setObjective(sum(residuals)) m.setMinimize() m.optimize() solution = m.getBestSol() return [solution[xi] for xi in x] We also provide a convenience function for counting the number of correct predictions by our resulting model against either the test or training data sets.\ndef count_correct(data_set, coefficients): \u0026#39;\u0026#39;\u0026#39;Returns the number of correct predictions.\u0026#39;\u0026#39;\u0026#39; correct = 0 for d in data_set: result = sum(x*y for x, y in zip(coefficients, d[\u0026#39;input\u0026#39;])) # Do we predict the same as the output? if (result \u0026gt;= 0) == (d[\u0026#39;output\u0026#39;] \u0026gt;= 0): correct += 1 return correct Finally we write a main method to read in the data, build our linear model, and test its efficacy.\nfrom pprint import pprint if __name__ == \u0026#39;__main__\u0026#39;: # Specs for this input file INPUT_FILE_NAME = \u0026#39;cancer1.dt\u0026#39; TRAIN_SIZE = 350 train_data, test_data = read_proben1_cancer_data( INPUT_FILE_NAME, TRAIN_SIZE ) # Add the offset variable to each of our data records for data_set in [train_data, test_data]: for row in data_set: row[\u0026#39;input\u0026#39;] = [1] + row[\u0026#39;input\u0026#39;] coefficients = train_linear_model(train_data) print(\u0026#39;coefficients:\u0026#39;) pprint(coefficients) # Print % of correct predictions for each data set correct = count_correct(train_data, coefficients) print( \u0026#39;%s / %s = %.02f%% correct on training set\u0026#39; % ( correct, len(train_data), 100 * float(correct) / len(train_data) ) ) correct = count_correct(test_data, coefficients) print( \u0026#39;%s / %s = %.02f%% correct on testing set\u0026#39; % ( correct, len(test_data), 100 * float(correct) / len(test_data) ) ) Results The result of running this model against the cancer1.dt data set is:\ncoefficients: [1.4072882449702786, -0.14014055927954652, -0.6239513714263405, -0.26727681774258882, 0.067107753841131157, -0.28300216102808429, -1.0355594670918404, -0.22774451038152174, -0.69871243677663608, -0.072575089848659444] 328 / 350 = 93.71% correct on training set 336 / 349 = 96.28% correct on testing set The accuracy is pretty good here against the both the training and testing sets, so this particular model generalizes well. This is about the simplest model we can implement for data fitting, and we\u0026rsquo;ll get to more complicated ones later, but it\u0026rsquo;s nice to see we can do so well so quickly. The coefficients correspond to using a function of this form, rounding off to three decimal places:\n$$ \\begin{align*} f(x) =\\ \u0026amp;1.407 - 0.140 x_1 - 0.624 x_2 - 0.267 x_3 + 0.067 x_4 - \\\\ \u0026amp;0.283 x_5 - 1.037 x_6 - 0.228 x_7 - 0.699 x_8 - 0.073 x_9 \\end{align*} $$\nResources cancer1.dt data file from proben1 Full source listing ","permalink":"https://ryanjoneil.github.io/posts/2010-11-23-data-fitting-1-linear-data-fitting/","summary":"Note: This post was updated to work with Python 3 and PySCIPOpt. The original version used Python 2 and python-zibopt.\nData fitting is one of those tasks that everyone should have at least some exposure to. Certainly developers and analysts will benefit from a working knowledge of its fundamentals and their implementations. However, in my own reading I\u0026rsquo;ve found it difficult to locate good examples that are simple enough to pick up quickly and come with accompanying source code.","title":"🧐 Data Fitting 1 - Linear Data Fitting"},{"content":"Note: This post was updated to work with Python 3.\nOne of the most useful tools one learns in an Operations Research curriculum is Monte Carlo Simulation. Its utility lies in its simplicity: one can learn vital information about nearly any process, be it deterministic or stochastic, without wading through the grunt work of finding an analytical solution. It can be used for off-the-cuff estimates or as a proper scientific tool. All one needs to know is how to simulate a given process and its appropriate probability distributions and parameters if that process is stochastic.\nHere\u0026rsquo;s how it works:\nConstruct a simulation that, given input values, returns a value of interest. This could be a pure quantity, like time spent waiting for a bus, or a boolean indicating whether or not a particular event occurs. Run the simulation a, usually large, number of times, each time with randomly generated input variables. Record its output values. Compute sample mean and variance of the output values. In the case of time spent waiting for a bus, the sample mean and variance are estimators of mean and variance for one\u0026rsquo;s wait time. In the boolean case, these represent probability that the given event will occur.\nOne can think of Monte Carlo Simulation as throwing darts. Say you want to find the area under a curve without integrating. All you must do is draw the curve on a wall and throw darts at it randomly. After you\u0026rsquo;ve thrown enough darts, the area under the curve can be approximated using the percentage of darts that end up under the curve times the total area.\nThis technique is often performed using a spreadsheet, but that can be a bit clunky and may make more complex simulations difficult. I\u0026rsquo;d like to spend a minute showing how it can be done in Python. Consider the following scenario:\nPassengers for a train arrive according to a Poisson process with a mean of 100 per hour. The next train arrives exponentially with a rate of 5 per hour. How many passers will be aboard the train?\nWe can simulate this using the fact that a Poisson process can be represented as a string of events occurring with exponential inter-arrival times. We use the sim() function below to generate the number of passengers for random instances of the problem. We then compute sample mean and variance for these values.\nimport random PASSENGERS = 100.0 TRAINS = 5.0 ITERATIONS = 10000 def sim(): passengers = 0.0 # Determine when the train arrives train = random.expovariate(TRAINS) # Count the number of passenger arrivals before the train now = 0.0 while True: now += random.expovariate(PASSENGERS) if now \u0026gt;= train: break passengers += 1.0 return passengers if __name__ == \u0026#39;__main__\u0026#39;: output = [sim() for _ in range(ITERATIONS)] total = sum(output) mean = total / len(output) sum_sqrs = sum(x*x for x in output) variance = (sum_sqrs - total * mean) / (len(output) - 1) print(\u0026#39;E[X] = %.02f\u0026#39; % mean) print(\u0026#39;Var(X) = %.02f\u0026#39; % variance) ","permalink":"https://ryanjoneil.github.io/posts/2009-10-08-monte-carlo-simulation-in-python/","summary":"Note: This post was updated to work with Python 3.\nOne of the most useful tools one learns in an Operations Research curriculum is Monte Carlo Simulation. Its utility lies in its simplicity: one can learn vital information about nearly any process, be it deterministic or stochastic, without wading through the grunt work of finding an analytical solution. It can be used for off-the-cuff estimates or as a proper scientific tool.","title":"🐍 Monte Carlo Simulation in Python"},{"content":"One of the difficulties we encounter in solving the Traveling Salesman Problem (TSP) is that, for even a small numer of cities, a complete description of the problem requires a factorial number of constraints. This is apparent in the standard formulation used to teach the TSP to OR students. Consider a set of $n$ cities with the distance from city $i$ to city $j$ denoted $d_{ij}$. We attempt to minimize the total distance of a tour entering and leaving each city exactly once. $x_{ij} = 1$ if the edge from city $i$ to city $j$ is included in the tour, $0$ otherwise:\n$$ \\small \\begin{align*} \\min\\quad \u0026amp; z = \\sum_i \\sum_{j\\ne i} d_{ij} x_{ij}\\\\ \\text{s.t.}\\quad\u0026amp; \\sum_{j\\ne i} x_{ij} = 1 \u0026amp;\\quad\\forall\u0026amp;\\ i \u0026amp; \\text{leave each city once}\\\\ \u0026amp; \\sum_{i\\ne j} x_{ij} = 1 \u0026amp;\\quad\\forall\u0026amp;\\ j \u0026amp; \\text{enter each city once}\\\\ \u0026amp; x_{ij} \\in \\{0,1\\} \u0026amp;\\quad\\forall\u0026amp;\\ i,j \\end{align*} $$\nThis appears like a reasonable formulation until we solve it and see that our solution contains disconnected subtours. Suppose we have four cities, labeled $A$ through $D$. Connecting $A$ to $B$, $B$ to $A$, $C$ to $D$ and $D$ to $C$ provides a feasible solution to our formulation, but does not constitute a cycle. Here is a more concrete example of two disconnected subtours $\\{(1,5),(5,1)\\}$ and $\\{(2,3),(3,4),(4,2)\\}$ over five cities:\nampl: display x; x [*,*] : 1 2 3 4 5 := 1 0 0 0 0 1 2 0 0 1 0 0 3 0 0 0 1 0 4 0 1 0 0 0 5 1 0 0 0 0 ; Realizing we just solved the Assignment Problem, we now add subtour elimination constraints. These require that any proper, non-null subset of our $n$ cities is connected by at most $n-1$ active edges:\n$$ \\sum_{i \\in S} \\sum_{j \\in S} x_{ij} \\leq |S|-1 \\quad\\forall\\ S \\subset {1, \u0026hellip;, n}, S \\ne O $$\nIndexing subtour elimination constraints over a power set of the cities completes the formulation. However, this requires an additional $\\sum_{k=2}^{n-1} \\begin{pmatrix} n \\\\ k \\end{pmatrix}$ rows tacked on the end of our matrix and is clearly infeasible for large $n$. The most current computers can handle using this approach is around 19 cities. It remains an instructive tool for understanding the combinatorial explosion that occurs in problems like TSP and is worth translating into a modeling language. So how does one model it on a computer?\nUnfortunately, AMPL, the gold standard in mathematical modeling languages, is unable to index over sets. Creating a power set in AMPL requires going through a few contortions. The following code demonstrates power and index sets over four cities:\nset cities := 1 .. 4 ordered; param n := card(cities); set indices := 0 .. (2^n - 1); set power {i in indices} := {c in cities: (i div 2^(ord(c) - 1)) mod 2 = 1}; display cities; display n; display indices; display power; This yields the following output:\nset cities := 1 2 3 4; n = 4 set indices := 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; set power[0] := ; # empty set power[1] := 1; set power[2] := 2; set power[3] := 1 2; set power[4] := 3; set power[5] := 1 3; set power[6] := 2 3; set power[7] := 1 2 3; set power[8] := 4; set power[9] := 1 4; set power[10] := 2 4; set power[11] := 1 2 4; set power[12] := 3 4; set power[13] := 1 3 4; set power[14] := 2 3 4; set power[15] := 1 2 3 4; Note how the index set contains an index for each row in our power set. We can now generate the subtour elimination constraints:\nvar x {cities cross cities} binary; s.t. subtours {i in indices: card(power[i]) \u0026gt; 1 and card(power[i]) \u0026lt; card(cities)}: sum {(c,k) in power[i] cross power[i]: k != c} x[c,k] \u0026lt;= card(power[i]) - 1; expand subtours; subject to subtours[3]: x[1,2] + x[2,1] \u0026lt;= 1; subject to subtours[5]: x[1,3] + x[3,1] \u0026lt;= 1; subject to subtours[6]: x[2,3] + x[3,2] \u0026lt;= 1; subject to subtours[7]: x[1,2] + x[1,3] + x[2,1] + x[2,3] + x[3,1] + x[3,2] \u0026lt;= 2; subject to subtours[9]: x[1,4] + x[4,1] \u0026lt;= 1; subject to subtours[10]: x[2,4] + x[4,2] \u0026lt;= 1; subject to subtours[11]: x[1,2] + x[1,4] + x[2,1] + x[2,4] + x[4,1] + x[4,2] \u0026lt;= 2; subject to subtours[12]: x[3,4] + x[4,3] \u0026lt;= 1; subject to subtours[13]: x[1,3] + x[1,4] + x[3,1] + x[3,4] + x[4,1] + x[4,3] \u0026lt;= 2; subject to subtours[14]: x[2,3] + x[2,4] + x[3,2] + x[3,4] + x[4,2] + x[4,3] \u0026lt;= 2; While this does work, the code for generating the power set looks like voodoo. Understanding it required piece-by-piece decomposition, an exercise I suggest you go through yourself if you have a copy of AMPL and 15 minutes to spare:\nset foo {c in cities} := {ord(c)}; set bar {c in cities} := {2^(ord(c) - 1)}; set baz {i in indices} := {c in cities: i div 2^(ord(c) - 1)}; set qux {i in indices} := {c in cities: (i div 2^(ord(c) - 1)) mod 2 = 1}; display foo; display bar; display baz; display qux; This may be an instance where open source leads commercial software. The good folks who produce the SCIP Optimization Suite provide an AMPL-like language called ZIMPL with a few additional useful features. One of these is power sets. Compared to the code above, doesn\u0026rsquo;t this look refreshing?\nset cities := {1 to 4}; set power[] := powerset(cities); set indices := indexset(power); ","permalink":"https://ryanjoneil.github.io/posts/2009-02-27-on-the-beauty-of-power-sets/","summary":"One of the difficulties we encounter in solving the Traveling Salesman Problem (TSP) is that, for even a small numer of cities, a complete description of the problem requires a factorial number of constraints. This is apparent in the standard formulation used to teach the TSP to OR students. Consider a set of $n$ cities with the distance from city $i$ to city $j$ denoted $d_{ij}$. We attempt to minimize the total distance of a tour entering and leaving each city exactly once.","title":"⚡️ On the Beauty of Power Sets"},{"content":"Uncapacitated Lot Sizing (ULS) is a classic OR problem that seeks to minimize the cost of satisfying known demand for a product over time. Demand is subject to varying costs for production, set-up, and storage of the product. Technically, it is a mixed binary integer linear program \u0026ndash; the key point separating it from the world of linear optimization being that production cannot occur during any period without paying that period\u0026rsquo;s fixed costs for set-up. Thus it has linear nonnegative variables for production and storage amounts during each period, and a binary variable for each period that determines whether or not production can actually occur.\nFor $n$ periods with per-period fixed set-up cost $f_t$, unit production cost $p_t$, unit storage cost $h_t$,and demand $d_t$, we define decision variables related to production and storage quantities:\n$$ \\small \\begin{align*} x_t \u0026amp;= \\text{units produced in period}\\ t\\\\ s_t \u0026amp;= \\text{stock at the end of period}\\ t\\\\ y_t \u0026amp;= 1\\ \\text{if production occurs in period}\\ t, 0\\ \\text{otherwise} \\end{align*} $$\nOne can minimize overall cost for satisfying all demand on time using the following model per Wolsey (1998), defined slightly differently here:\n$$ \\small \\begin{align*} \\min\\quad \u0026amp; z = \\sum_t{p_t x_t} + \\sum_t{h_t s_t} + \\sum_t{f_t y_t}\\\\ \\text{s.t.}\\quad\u0026amp; s_1 = d_1 + s_1\\\\ \u0026amp; s_{t-1} + x_t = d_t + s_t \u0026amp;\\quad\\forall\u0026amp;\\ t \u0026gt; 1\\\\ \u0026amp; x_t \\leq M y_t \u0026amp;\\quad\\forall\u0026amp;\\ t\\\\ \u0026amp; s_t, x_t \\geq 0 \u0026amp;\\quad\\forall\u0026amp;\\ t\\\\ \u0026amp; y_t \\in {0,1} \u0026amp;\\quad\\forall\u0026amp;\\ t \\end{align*} $$\nAccording to Wolsey, page 11, given that $s_t = \\sum_{i=1}^t (x_i - d_i)$ and defining new constants $K = \\sum_{t=1}^n h_t(\\sum_{i=1}^t d_i)$ and $c_t = p_t + \\sum_{i=t}^n h_i$, the objective function can be rewritten as $z = \\sum_t c_t x_t + \\sum _t f_t y_t - K$. The book lacks a proof of this and it seems a bit non-obvious, so I attempt an explanation in somewhat painstaking detail here.\n$$ \\small \\begin{align*} \u0026amp;\\text{Proof}:\\\\ \u0026amp; \u0026amp; \\sum_t p_t x_t + \\sum_t h_t s_t + \\sum_t f_t y_t \u0026amp;= \\sum_t c_t x_t + \\sum _t f_t y_t - K\\\\ \u0026amp;\\text{1. Remove} \\sum_t f_t y_t:\\\\ \u0026amp; \u0026amp; \\sum_t p_t x_t + \\sum_t h_t s_t \u0026amp;= \\sum_t c_t x_t - K\\\\ \u0026amp;\\text{2. Expand}\\ K\\ \\text{and}\\ c_t:\\\\ \u0026amp; \u0026amp; \\sum_t p_t x_t + \\sum_t h_t s_t \u0026amp;= \\sum_t (p_t + \\sum_{i=t}^n h_i) x_t - \\sum_t h_t (\\sum_{i=1}^t d_i)\\\\ \u0026amp;\\text{3. Remove}\\ \\sum_t p_t x_t:\\\\ \u0026amp; \u0026amp; \\sum_t h_t s_t \u0026amp;= \\sum_t x_t (\\sum_{i=t}^n h_i) - \\sum_t h_t (\\sum_{i=1}^t d_i)\\\\ \u0026amp;\\text{4. Expand}\\ s_t:\\\\ \u0026amp; \u0026amp; \\sum_t h_t (\\sum_{i=1}^t x_i) - \\sum_t h_t (\\sum_{i=1}^t d_i) \u0026amp;= \\sum_t x_t (\\sum_{i=t}^n h_i) - \\sum_t h_t (\\sum_{i=1}^t d_i)\\\\ \u0026amp;\\text{5. Remove}\\ \\sum_t h_t (\\sum_{i=1}^t d_i):\\\\ \u0026amp; \u0026amp; \\sum_t h_t (\\sum_{i=1}^t x_i) \u0026amp;= \\sum_t x_t (\\sum_{i=t}^n h_i) \\end{align*} $$\nThe result from step 5 becomes obvious upon expanding its left and right-hand terms:\n$$ h_1 x_1 + h_2 (x_1 + x_2) + \\cdots + h_n (x_1 + \\cdots + x_n) =\\\\ x_1 (h_1 + \\cdots + h_n) + x2 (h_2 + \\cdots + h_n) + \\cdots + x_n h_n $$\nIn matrix notation with $h$ and $x$ as column vectors in $\\bf R^n$ and $L$ and $U$ being $n \\times n$ lower and upper triangular identity matrices, respectively, this can be written as:\n$$ \\small \\begin{pmatrix} h_1 \\cdots h_n \\end{pmatrix} \\begin{pmatrix} 1 \\cdots 0 \\\\ \\vdots \\ddots \\vdots \\\\ 1 \\cdots 1 \\end{pmatrix} \\begin{pmatrix} x_1 \\\\ \\vdots \\\\ x_n \\end{pmatrix} = \\begin{pmatrix} x_1 \\cdots x_n \\end{pmatrix} \\begin{pmatrix} 1 \\cdots 1 \\\\ \\vdots \\ddots \\vdots \\\\ 0 \\cdots 1 \\end{pmatrix} \\begin{pmatrix} h_1 \\\\ \\vdots \\\\ h_n \\end{pmatrix} $$\nor $h^T L x = x^T U h$.\n","permalink":"https://ryanjoneil.github.io/posts/2009-02-20-uncapacitated-lot-sizing/","summary":"Uncapacitated Lot Sizing (ULS) is a classic OR problem that seeks to minimize the cost of satisfying known demand for a product over time. Demand is subject to varying costs for production, set-up, and storage of the product. Technically, it is a mixed binary integer linear program \u0026ndash; the key point separating it from the world of linear optimization being that production cannot occur during any period without paying that period\u0026rsquo;s fixed costs for set-up.","title":"📐 Uncapacitated Lot Sizing"}]